/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.
Copyright 2022 The StableHLO Authors.
Copyright 2025 The StableHLO(Fractalyze) Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#include "stablehlo/dialect/TypeInference.h"

#include <algorithm>
#include <numeric>

#include "llvm/ADT/BitVector.h"
#include "llvm/ADT/DenseSet.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/STLFunctionalExtras.h"
#include "llvm/ADT/Twine.h"
#include "llvm/ADT/iterator_range.h"
#include "llvm/Support/MathExtras.h"
#include "mlir/IR/Block.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/Matchers.h"
#include "mlir/IR/TypeRange.h"
#include "mlir/IR/ValueRange.h"

#include "prime_ir/Dialect/Field/IR/FieldTypes.h"
#include "stablehlo/dialect/Base.h"

namespace mlir::hlo {
namespace {

//===----------------------------------------------------------------------===//
// Utils for shape functions.
//===----------------------------------------------------------------------===//

bool tensorsHaveSameElType(TypeRange types) {
  if (!types.empty()) {
    auto tensorTy1 = cast<ShapedType>(types[0]);
    Type tensorEl1 = tensorTy1.getElementType();
    for (auto otherTensor : llvm::drop_begin(types, 1)) {
      auto tensorTy2 = cast<ShapedType>(otherTensor);
      Type tensorEl2 = tensorTy2.getElementType();
      if (tensorEl1 != tensorEl2)
        return false;
    }
  }
  return true;
}

// Return true if type1 and type2 are tensors and have the same
// element-type, else return false.
bool tensorsHaveSameElType(Type type1, Type type2) {
  return tensorsHaveSameElType({type1, type2});
}

// Returns the types of the terminator arguments of the input mlir::Block
// 'block'.
FailureOr<SmallVector<ShapedType>>
getAccumulatorTypes(std::optional<Location> loc, Region &region) {
  if (region.empty()) {
    return emitOptionalError(
        loc, "Expects non-empty reduction block for type inference");
  }

  Block &block = region.front();
  return llvm::map_to_vector(
      block.getTerminator()->getOperands(),
      [&](Value v) { return cast<ShapedType>(v.getType()); });
}

// Shape function can be called directly from autogenerated `build()` function,
// which may not guarantee the added region(s) in `odsState.regions` to be
// non-empty. Need check it here to avoid a crash for the ops that need regions
// in type inference, i.e. `IfOp/CaseOp/MapOp`.
LogicalResult verifyRegionNotEmpty(std::optional<Location> location,
                                   Region &region) {
  if (region.empty())
    return emitOptionalError(location, "expect non-empty region");
  return success();
}

// Used by IfOp and CaseOp
LogicalResult inferConditionalOp(std::optional<Location> location,
                                 Value operand, RegionRange branches,
                                 SmallVectorImpl<Type> &inferredReturnTypes) {
  // case_i1, if_i1
  auto operandRankedTy = cast<RankedTensorType>(operand.getType());
  if (operandRankedTy.getRank() != 0)
    return emitOptionalError(location,
                             "operand should be rank 0 tensor but got rank ",
                             operandRankedTy.getRank());
  // case_c1
  if (branches.empty())
    return emitOptionalError(location, "expect at least one branch");
  for (auto region : branches)
    if (failed(verifyRegionNotEmpty(location, *region)))
      return failure();

  ValueTypeRange<OperandRange> branch0ResultTypes =
      branches[0]->front().getTerminator()->getOperandTypes();
  for (unsigned i = 0; i < branches.size(); ++i) {
    Twine branchName = "branch " + Twine(i);
    Region *region = branches[i];
    // case_c2, if_c1
    if (region->getNumArguments() != 0)
      return emitOptionalError(location, branchName,
                               " must have 0 arguments, but found ",
                               region->getNumArguments());
    // case_c3, if_c2
    auto branchResultTypes = region->front().getTerminator()->getOperandTypes();
    if (!hlo::isCompatibleForHloTypeInference(branch0ResultTypes,
                                              branchResultTypes))
      return emitOptionalError(location, "branch 0 and ", branchName,
                               " have mismatched return types: ",
                               branch0ResultTypes, " vs ", branchResultTypes);
  }
  // case_c4, if_c3
  for (unsigned i = 0; i < branch0ResultTypes.size(); ++i) {
    SmallVector<Type> inputTypes;
    for (auto branch : branches)
      inputTypes.push_back(
          branch->front().getTerminator()->getOperandTypes()[i]);
    auto inferredTypeOrErr = inferLeastSpecificType(location, inputTypes);
    if (failed(inferredTypeOrErr))
      return failure();
    inferredReturnTypes.emplace_back(*inferredTypeOrErr);
  }
  return success();
}

LogicalResult verifyDimInBounds(std::optional<Location> loc, ShapedType type,
                                int64_t dim) {
  if (dim < 0)
    return emitOptionalError(
        loc, "requires non-negative dimension attribute; found (", dim, ")");
  if (dim >= type.getRank())
    return emitOptionalError(loc, "requires dimension attribute in range [0, ",
                             type.getRank(), "); found (", dim, ")");
  return success();
}

// Return true if type1 and type2 are shape-compatible and have same element
// type.
bool compatibleShapeAndElementType(Type type1, Type type2) {
  if (failed(verifyCompatibleShape(type1, type2)))
    return false;
  return tensorsHaveSameElType(type1, type2);
}

} // namespace

bool verifyCompatibleDims(int64_t dimSize1, int64_t dimSize2) {
  return isDynamicDimSize(dimSize1) || isDynamicDimSize(dimSize2) ||
         dimSize1 == dimSize2;
}

FailureOr<SmallVector<std::pair<int64_t, int64_t>>>
convertPaddingAttribute(std::optional<DenseIntElementsAttr> optionalAttr,
                        std::optional<Location> loc) {
  if (!optionalAttr.has_value())
    return SmallVector<std::pair<int64_t, int64_t>>{};

  DenseIntElementsAttr attr = *optionalAttr;
  auto attrType = cast<RankedTensorType>(attr.getType());
  if (attrType.getRank() != 2 || attrType.getShape()[1] != 2)
    return emitOptionalError(
        loc, "expects the shape of padding-attribute to be {N, 2}, but got {",
        attrType.getShape(), "}.");

  auto it = attr.getValues<int64_t>().begin();
  SmallVector<std::pair<int64_t, int64_t>> out(attr.getNumElements() / 2);
  for (auto &item : out) {
    int64_t first = *it;
    ++it;
    int64_t second = *it;
    ++it;
    item = {first, second};
  }
  return out;
}

// If a window with the given bound in some dimension is dilated with the given
// dilation factor in that dimension, then the value returned is the bound for
// the array in that dimension after dilation.
//
// For a 1D array with 3 entries 1, 2, 3, a dilation factor of 2 yields a new
// window with values 1, x, 2, x, 3, where x indicates holes left by the
// dilation. So DilatedBound(3, 2) == 5.
int64_t dilatedBound(int64_t bound, int64_t dilation) {
  assert(bound >= 0 && "The dimension to dilate must be >= 0");
  if (bound == 0)
    return 0;

  // Suppose the array has three entries 123 and the dilation factor is 4. Then
  // the dilated array has 9 entries 1xxx2xxx3. Here, each original entry except
  // the last expands into 4 entries, so that is (bound - 1) * dilation. Then we
  // add 1 to account for the final input element.
  return (bound - 1) * dilation + 1;
}

// Returns the number of valid positions of a window with the given size and
// stride within an array with the given bound. This is the bound of an output
// array with one element per valid position of the window.
//
// For example, for arguments of (bound=5, window_size=2, stride=2), the
// returned value is 2. There are valid positions at offset 0 and offset 2,
// while offset 4 is not valid since the window's last entry would be at 5,
// which is beyond the bound of 5.
int64_t stridedBound(int64_t bound, int64_t windowSize, int64_t stride) {
  assert(windowSize >= 0 && "Expected window size to be >= 0");
  assert(bound >= 0 && "Expected bound to be >= 0");

  if (bound == 0 || windowSize > bound)
    return 0;

  // Without considering stride, the maximum valid offset is bound -
  // window_size. Taking stride into account, the valid offsets then have the
  // form q * stride for q = 0, ..., Q such that q * stride <= bound -
  // window_size. This implies that Q equals floor(bound - window_size /
  // stride). There are Q + 1 valid values of q, yielding the formula below.
  return (bound - windowSize) / stride + 1;
}

// Verifies various properties of window-attributes (viz., stride, padding,
// lhs_dilation and rhs_dilation) and collects all the window-attributes for
// each kernel spatial dimensions.
FailureOr<SmallVector<WindowDimension>>
verifyWindowAttributesAndInferWindowDimensions(
    ArrayRef<int64_t> windowDimensions, ArrayRef<int64_t> windowStrides,
    ArrayRef<std::pair<int64_t, int64_t>> padding,
    ArrayRef<int64_t> lhsDilation, ArrayRef<int64_t> rhsDilation,
    ArrayRef<bool> windowReversal, std::optional<Location> loc) {
  const auto verifySize = [&](const size_t attrSize,
                              StringRef attrName) -> LogicalResult {
    if (attrSize == 0 || attrSize == windowDimensions.size())
      return success();
    return emitOptionalError(
        loc, "expects ", attrName,
        " to have same dimension-size as size of window dimensions (",
        windowDimensions.size(), "), but got: ", attrSize, ".");
  };
  // reduce_window_c6
  if (failed(verifySize(windowStrides.size(), "window-strides")))
    return failure();
  // reduce_window_c8
  if (failed(verifySize(lhsDilation.size(), "base-dilation factors")))
    return failure();
  // reduce_window_c10
  if (failed(verifySize(rhsDilation.size(), "window-dilation factors")))
    return failure();
  // reduce_window_c12
  if (failed(verifySize(padding.size(), "padding-entries")))
    return failure();
  if (failed(verifySize(windowReversal.size(), "window-reversal")))
    return failure();

  SmallVector<WindowDimension> window(windowDimensions.size());
  for (size_t i = 0; i < windowDimensions.size(); i++) {
    WindowDimension &dim = window[i];
    dim.size = windowDimensions[i];

    // reduce_window_c5
    if (!isDynamicDimSize(dim.size) && dim.size <= 0)
      return emitOptionalError(loc,
                               "expects window to have positive value for ", i,
                               "-th window dimension, but got ", dim.size, ".");

    if (!windowStrides.empty())
      dim.stride = windowStrides[i];
    // reduce_window_c7
    if (dim.stride <= 0)
      return emitOptionalError(
          loc, "expects window to have positive stride for ", i,
          "-th window dimension, but got ", dim.stride, ".");

    if (!lhsDilation.empty())
      dim.baseDilation = lhsDilation[i];
    // reduce_window_c9
    if (dim.baseDilation <= 0)
      return emitOptionalError(
          loc, "expects window to have positive base dilation factor for ", i,
          "-th window dimension, but got ", dim.baseDilation, ".");

    if (!rhsDilation.empty())
      dim.windowDilation = rhsDilation[i];
    // reduce_window_c11
    if (dim.windowDilation <= 0)
      return emitOptionalError(
          loc, "expects window to have positive window dilation factor for ", i,
          "-th window dimension, but got ", dim.windowDilation, ".");

    if (!padding.empty()) {
      dim.paddingLow = padding[i].first;
      dim.paddingHigh = padding[i].second;
    }
  }

  return window;
}

// Infer the shape of the output window.
//  Foreach dimension d,
//    output-window-shape[d] =
//            stridedBound(padding_low + dilatedBound(base_shape[d]) +
//            padding_high,
//                         dilatedBound(window_shape[d]))
//      where (padding_low, padding_high) is the padding-pair for d.
SmallVector<int64_t> inferWindowOutputShape(ArrayRef<int64_t> baseShape,
                                            ArrayRef<WindowDimension> window) {
  assert(baseShape.size() == window.size() &&
         "Size of window dimensions must match the size of base shape.");

  SmallVector<int64_t> outputDimensions(window.size());
  for (int64_t i = 0; i < static_cast<int64_t>(window.size()); ++i) {
    if (isDynamicDimSize(baseShape[i]) || isDynamicDimSize(window[i].size)) {
      outputDimensions[i] = ShapedType::kDynamic;
    } else {
      const auto &dim = window[i];

      const int64_t dilatedBase = dilatedBound(baseShape[i], dim.baseDilation);
      const int64_t paddedDilatedBase =
          dim.paddingLow + dilatedBase + dim.paddingHigh;
      const int64_t dilatedWindow = dilatedBound(dim.size, dim.windowDilation);

      outputDimensions[i] =
          stridedBound(paddedDilatedBase, dilatedWindow, dim.stride);
    }
  }

  return outputDimensions;
}

//===----------------------------------------------------------------------===//
// Shape functions for ops.
//===----------------------------------------------------------------------===//

LogicalResult inferAbsOp(std::optional<Location>, Value operand,
                         SmallVectorImpl<Type> &inferredReturnTypes) {
  auto operandTy = cast<ShapedType>(operand.getType());
  // abs_c2
  Type elementTy = operandTy.getElementType();
  // abs_c1
  inferredReturnTypes.push_back(operandTy.clone(elementTy));
  return success();
}

LogicalResult
inferBroadcastOp(std::optional<Location> location, Value operand,
                 ArrayRef<int64_t> broadcastSizes,
                 SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  auto operandType = cast<RankedTensorType>(operand.getType());

  for (int64_t size : broadcastSizes)
    if (size < 0)
      return emitOptionalError(location,
                               "Broadcast with negative dimension size ", size);
  SmallVector<int64_t> shapeValues(broadcastSizes);
  llvm::append_range(shapeValues, operandType.getShape());

  inferredReturnShapes.emplace_back(shapeValues, operandType.getElementType());
  return success();
}

LogicalResult inferCaseOp(std::optional<Location> location, Value index,
                          RegionRange branches,
                          SmallVectorImpl<Type> &inferredReturnTypes) {
  return inferConditionalOp(location, index, branches, inferredReturnTypes);
}

LogicalResult
inferClampOp(std::optional<Location> location, Value min, Value operand,
             Value max,
             SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  auto operandType = cast<RankedTensorType>(operand.getType());
  auto operandShape = operandType.getShape();
  auto minType = cast<RankedTensorType>(min.getType());

  // clamp_c1
  auto minShape = minType.getShape();
  if (failed(verifyCompatibleShape(minType, operandType)) &&
      minType.getRank() != 0)
    return emitOptionalError(
        location, "min shape [",
        llvm::make_range(minShape.begin(), minShape.end()),
        "] is not scalar and is not compatible to operand shape [",
        llvm::make_range(operandShape.begin(), operandShape.end()), "]");

  // clamp_c2
  auto maxType = cast<RankedTensorType>(max.getType());
  auto maxShape = maxType.getShape();
  if (failed(verifyCompatibleShape(maxType, operandType)) &&
      maxType.getRank() != 0)
    return emitOptionalError(
        location, "max shape [",
        llvm::make_range(maxShape.begin(), maxShape.end()),
        "] is not scalar and is not compatible to operand shape [",
        llvm::make_range(operandShape.begin(), operandShape.end()), "]");

  // clamp_c4
  inferredReturnShapes.emplace_back<ShapedType>(operandType);
  return success();
}

LogicalResult
inferCompareOp(MLIRContext *context, std::optional<Location>, Value lhs,
               SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  // compare_c1
  ShapedTypeComponents &components =
      inferredReturnShapes.emplace_back(IntegerType::get(context, /*width=*/1));
  auto argTy = cast<ShapedType>(lhs.getType());
  // compare_c2
  components =
      ShapedTypeComponents(argTy.getShape(), components.getElementType());
  return success();
}

LogicalResult inferConcatenateOp(std::optional<Location> location,
                                 TypeRange inputTypes, int64_t dimension,
                                 SmallVectorImpl<Type> &inferredReturnTypes) {
  auto witnessType = cast<RankedTensorType>(inputTypes[0]);
  int64_t rank = witnessType.getRank();

  // concatenate_c4
  if (rank == 0)
    return emitOptionalError(location, "rank-0 values cannot be concatenated");
  if (dimension >= rank)
    return emitOptionalError(location, "dimension ", dimension,
                             " is out-of-bounds for input rank ", rank);

  // concatenate_c2
  for (size_t i = 0; i < inputTypes.size(); i++) {
    auto type = cast<RankedTensorType>(inputTypes[i]);
    if (type.getRank() != rank)
      return emitOptionalError(location, "operands (0) and (", i,
                               ") do not match rank");

    auto witnessShape = witnessType.getShape();
    auto shape = type.getShape();
    for (int d = 0; d < rank; ++d) {
      if (d != dimension && !verifyCompatibleDims(witnessShape[d], shape[d]))
        return emitOptionalError(
            location, "shapes of operand (", 0, ") and (", i,
            ") are not compatible at non-concat index ", d, ": (",
            llvm::make_range(witnessShape.begin(), witnessShape.end()),
            ") != (", llvm::make_range(shape.begin(), shape.end()), ")");
    }
  }

  // Infer the most specific (size, bound) of all dimensions of the return type
  SmallVector<int64_t> inferredSizes(rank, ShapedType::kDynamic);
  SmallVector<int64_t> inferredBounds(rank, ShapedType::kDynamic);
  // Note: for the concatenate dimension, 0 should be the identity element:
  // Any dim size can be kept unchanged when concatenated with 0.
  inferredSizes[dimension] = 0;
  bool anyInputHaveBounds = false;

  for (const auto &it : llvm::enumerate(inputTypes)) {
    RankedTensorType rankedType = cast<RankedTensorType>(it.value());
    SmallVector<int64_t> bounds;
    bounds = llvm::to_vector(encodingToBounds(rankedType.getEncoding()));
    if (!bounds.empty())
      anyInputHaveBounds = true;

    for (int dim = 0; dim < rank; ++dim) {
      std::pair<int64_t, int64_t> inferredDimAndBound;

      int64_t leftSize = inferredSizes[dim];
      int64_t rightSize = rankedType.getShape()[dim];
      int64_t leftBound = inferredBounds[dim];
      int64_t rightBound = bounds.empty() ? ShapedType::kDynamic : bounds[dim];
      if (dim == dimension) {
        inferredDimAndBound = inferConcatenatedDimAndBound(
            leftSize, rightSize, leftBound, rightBound);
      } else {
        auto inferredDimAndBoundOrErr = inferMostSpecificDimAndBound(
            location, dim, leftSize, rightSize, leftBound, rightBound);
        if (failed(inferredDimAndBoundOrErr))
          return failure();
        inferredDimAndBound = *inferredDimAndBoundOrErr;
      }
      inferredSizes[dim] = inferredDimAndBound.first;
      inferredBounds[dim] = inferredDimAndBound.second;
    }
  }
  // concatenate_c5, concatenate_c6
  inferredReturnTypes.push_back(RankedTensorType::get(
      inferredSizes, witnessType.getElementType(),
      boundsToEncoding(
          witnessType.getEncoding(),
          // Empty array as argument is an indicator to boundsToEncoding() that
          // there are no bounds at all in inputs, thus sparsity attributes will
          // be included in the return type
          anyInputHaveBounds ? inferredBounds : llvm::ArrayRef<int64_t>({}))));
  return success();
}

LogicalResult inferConstantOp(std::optional<Location>, ElementsAttr value,
                              SmallVectorImpl<Type> &inferredReturnTypes) {
  inferredReturnTypes.push_back(value.getType());
  return success();
}

LogicalResult
inferConvertOp(std::optional<Location> location, Value operand,
               SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  auto operandType = cast<ShapedType>(operand.getType());
  // convert_c1
  inferredReturnShapes.emplace_back(operandType.getShape());
  return success();
}

LogicalResult inferCreateTokenOp(HloDialectInterface *dialect,
                                 std::optional<Location> location,
                                 SmallVectorImpl<Type> &inferredReturnTypes) {
  inferredReturnTypes.push_back(dialect->createTokenType());
  return success();
}

LogicalResult inferDynamicSliceOp(
    std::optional<Location> location, Type operandType,
    TypeRange startIndicesTypes, ArrayRef<int64_t> sliceSizes,
    SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  // dynamic_slice_c2
  int numSliceSizes = sliceSizes.size();
  int numStartIndices = startIndicesTypes.size();
  if (numStartIndices != numSliceSizes)
    return emitOptionalError(location, "has mismatched number of slice sizes (",
                             numSliceSizes, ") and number of start indices (",
                             numStartIndices, ")");
  auto rankedOperandType = cast<RankedTensorType>(operandType);
  // dynamic_slice_c2
  if (rankedOperandType.getRank() != numStartIndices)
    return emitOptionalError(
        location, "has mismatched number of start indices (", numStartIndices,
        ") and the rank of operand (", rankedOperandType.getRank(), ")");

  // dynamic_slice_c3
  if (!tensorsHaveSameElType(startIndicesTypes))
    return emitOptionalError(location,
                             "start indices must have same element type");

  // dynamic_slice_c4
  for (int i = 0; i < numSliceSizes; ++i) {
    int64_t sliceSize = sliceSizes[i];
    if (sliceSize < 0)
      return emitOptionalError(
          location, "has negative size index to dynamic slice: ", sliceSize);
    if (!rankedOperandType.isDynamicDim(i)) {
      int64_t dimSize = rankedOperandType.getDimSize(i);
      if (sliceSize > dimSize)
        return emitOptionalError(location, "has slice size ", sliceSize,
                                 " greater than dimension size ", dimSize,
                                 " in dimension ", i, " of operand");
    }
  }

  // dynamic_slice_c5
  inferredReturnShapes.emplace_back(sliceSizes,
                                    rankedOperandType.getElementType());
  return success();
}

LogicalResult inferDynamicUpdateSliceOp(
    std::optional<Location> location, Value operand, Value update,
    ValueRange startIndices,
    SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  auto operandType = cast<ShapedType>(operand.getType());
  auto updateType = cast<ShapedType>(update.getType());

  // dynamic_update_slice_c3
  if (updateType.getRank() != operandType.getRank())
    return emitOptionalError(
        location,
        "update rank does not match operand rank: ", updateType.getRank(),
        " vs ", operandType.getRank(), ".");

  // dynamic_update_slice_c4
  if (static_cast<int64_t>(startIndices.size()) != operandType.getRank())
    return emitOptionalError(
        location, "expects number of start_indices to match operand rank: ",
        startIndices.size(), " vs ", operandType.getRank(), ".");

  // dynamic_update_slice_c5
  if (!tensorsHaveSameElType(startIndices.getTypes()))
    return emitOptionalError(location,
                             "start indices must have same element type");

  // dynamic_update_slice_c6
  for (auto [index, dims] : llvm::enumerate(
           llvm::zip(operandType.getShape(), updateType.getShape()))) {
    auto [operandDim, updateDim] = dims;
    if (isDynamicDimSize(updateDim))
      continue;
    if (isStaticDimSize(operandDim)) {
      if (updateDim < 0 || updateDim > operandDim)
        return emitOptionalError(location, "expects size at dimension ", index,
                                 " of update to be in range [0, ", operandDim,
                                 "]. Got: ", updateDim, ".");
    } else {
      if (updateDim < 0)
        return emitOptionalError(
            location, "expects size at dimension ", index,
            " of update to be non-negative. Got: ", updateDim, ".");
    }
  }

  // dynamic_update_slice_c1
  inferredReturnShapes.emplace_back(
      operandType.getShape(), operandType.getElementType(),
      cast<RankedTensorType>(operandType).getEncoding());
  return success();
}

LogicalResult inferGetDimensionSizeOp(
    std::optional<Location> location, Type operandType, int64_t dimension,
    SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  // get_dimension_size_c1
  if (failed(verifyDimInBounds(location, cast<ShapedType>(operandType),
                               dimension)))
    return failure();
  inferredReturnShapes.emplace_back(
      ArrayRef<int64_t>{}, IntegerType::get(operandType.getContext(), 32));
  return success();
}

LogicalResult
inferGetTupleElementOp(std::optional<Location> location, Value operand,
                       int32_t index,
                       SmallVectorImpl<Type> &inferredReturnTypes) {
  auto operandType = dyn_cast<TupleType>(operand.getType());
  if (!operandType)
    return failure();
  // get_tuple_element_c1
  if (index >= static_cast<int64_t>(operandType.size()))
    return emitOptionalError(location, "index ", index,
                             " is out of bounds of operand with size ",
                             operandType.size());

  // get_tuple_element_c2
  inferredReturnTypes.push_back(operandType.getType(index));
  return success();
}

LogicalResult inferIfOp(std::optional<Location> location, Value pred,
                        RegionRange branches,
                        SmallVectorImpl<Type> &inferredReturnTypes) {
  return inferConditionalOp(location, pred, branches, inferredReturnTypes);
}

LogicalResult
inferMapOp(std::optional<Location> location, ValueRange inputs,
           ArrayRef<int64_t> dimensions, Region &computation,
           SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  if (failed(verifyRegionNotEmpty(location, computation)))
    return failure();

  // map_c4
  auto &computationBlock = computation.front();
  auto computationArgs = computationBlock.getArguments();
  if (inputs.size() != computationArgs.size())
    return emitOptionalError(location,
                             "expects number of operands to match the arity of "
                             "map computation, but got: ",
                             inputs.size(), " and ", computationArgs.size());

  // map_c4
  for (const auto &indexedArg : llvm::enumerate(computationArgs)) {
    auto argType = cast<RankedTensorType>(indexedArg.value().getType());
    if (argType.getRank() != 0)
      return emitOptionalError(
          location,
          "computation arguments must be 0-rank tensor, but got: arg #",
          indexedArg.index(), " of type ", indexedArg.value().getType());
    auto operandElemTy =
        cast<ShapedType>(inputs[indexedArg.index()].getType()).getElementType();
    if (argType.getElementType() != operandElemTy)
      return emitOptionalError(location,
                               "element type of operands and computation "
                               "arguments must match, but got: ",
                               operandElemTy, " and ",
                               argType.getElementType());
  }

  // map_c4
  auto computationOutputs = computationBlock.getTerminator()->getOperands();
  if (computationOutputs.size() != 1)
    return emitOptionalError(location,
                             "computation must return single output, but got: ",
                             computationOutputs.size());

  // map_c4
  auto computationOutputType =
      cast<RankedTensorType>(computationOutputs[0].getType());
  if (computationOutputType.getRank() != 0)
    return emitOptionalError(location,
                             "computation must return 0-rank tensor, but got: ",
                             computationOutputs[0].getType());

  // map_c3
  for (const auto &indexedValue : llvm::enumerate(dimensions)) {
    if (indexedValue.value() != static_cast<int64_t>(indexedValue.index()))
      return emitOptionalError(
          location,
          "requires monotonically increasing dimension numbers, but got: ",
          dimensions);
  }

  // map_c3
  ArrayRef<int64_t> resultShape;
  for (auto operand : inputs) {
    auto operandType = cast<ShapedType>(operand.getType());
    if (dimensions.size() != operandType.getShape().size())
      return emitOptionalError(
          location,
          "applied to a subset of dimensions currently not supported: operand "
          "dimensions = ",
          operandType.getShape().size(),
          ", requested map dimensions size = ", dimensions.size());
    resultShape = operandType.getShape();
  }

  // map_c4
  inferredReturnShapes.emplace_back(resultShape,
                                    computationOutputType.getElementType());
  return success();
}

LogicalResult inferPadOp(std::optional<Location> location, Type operandType,
                         Type paddingValueType,
                         ArrayRef<int64_t> edgePaddingLow,
                         ArrayRef<int64_t> edgePaddingHigh,
                         SmallVectorImpl<Type> &inferredReturnTypes) {
  auto inputType = cast<RankedTensorType>(operandType);

  int64_t rank = inputType.getRank();
  // pad_c2
  if (static_cast<int64_t>(edgePaddingLow.size()) != rank)
    return emitOptionalError(location, "edge_padding_low length (",
                             edgePaddingLow.size(),
                             ") must match operand rank (", rank, ")");

  auto inputShape = inputType.getShape();
  SmallVector<int64_t> resultShape(rank, ShapedType::kDynamic);
  ArrayRef<int64_t> inputBounds = encodingToBounds(inputType.getEncoding());
  SmallVector<int64_t> resultBounds(inputBounds.size(), ShapedType::kDynamic);

  for (int i = 0, e = inputShape.size(); i < e; i++) {
    int64_t paddingLowVal = edgePaddingLow[i];
    int64_t paddingHighVal = edgePaddingHigh[i];

    bool isStaticDim = !isDynamicDimSize(inputShape[i]);
    bool isStaticBound =
        !inputBounds.empty() && !isDynamicDimSize(inputBounds[i]);
    if (isStaticDim || isStaticBound) {
      int64_t operandSizeOrBound = isStaticDim ? inputShape[i] : inputBounds[i];
      int64_t resultSizeOrBound =
          operandSizeOrBound + paddingLowVal + paddingHighVal;

      // pad_c4
      if (resultSizeOrBound < 0) {
        auto sizeOrBound = isStaticDim ? "size" : "bound";
        return emitOptionalError(location, "Padding result in negative ",
                                 sizeOrBound, " for dimension ", i);
      }
      (isStaticDim ? resultShape : resultBounds)[i] = resultSizeOrBound;
    }
  }

  // pad_c1
  inferredReturnTypes.push_back(RankedTensorType::get(
      resultShape, inputType.getElementType(),
      boundsToEncoding(inputType.getEncoding(), resultBounds)));

  return success();
}

LogicalResult
inferReduceOp(std::optional<Location> location, TypeRange inputTypes,
              ArrayRef<int64_t> dimensions, Region &body,
              SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  auto inputArgTensorTypes = llvm::map_to_vector(
      inputTypes, [](Type t) { return cast<ShapedType>(t); });

  SmallVector<int64_t> newDimensions;
  Attribute encoding;
  // reduce_c1, reduce_c4, reduce_c5, reduce_i3
  if (failed(verifyReduceOpInputsAndInferShape(
          location, inputArgTensorTypes, dimensions, newDimensions, encoding)))
    return failure();
  // reduce_c3, reduce_c7, reduce_c8
  auto accumulatorTypesOrErr = getAccumulatorTypes(location, body);
  if (failed(accumulatorTypesOrErr))
    return failure();
  for (uint64_t inputIdx = 0; inputIdx < inputTypes.size(); ++inputIdx) {
    Type elementType = (*accumulatorTypesOrErr)[inputIdx].getElementType();
    inferredReturnShapes.emplace_back(newDimensions, elementType, encoding);
  }

  return success();
}

LogicalResult inferReduceWindowOp(
    std::optional<Location> location, ValueRange inputs, ValueRange initValues,
    ArrayRef<int64_t> windowDimensions,
    std::optional<ArrayRef<int64_t>> windowStrides,
    std::optional<ArrayRef<int64_t>> baseDilations,
    std::optional<ArrayRef<int64_t>> windowDilations,
    std::optional<DenseIntElementsAttr> padding, Region &body,
    SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  auto inputTypes = llvm::map_to_vector(
      inputs.getTypes(), [](Type t) { return cast<ShapedType>(t); });
  auto initValueTypes = llvm::map_to_vector(
      initValues.getTypes(), [](Type t) { return cast<ShapedType>(t); });

  SmallVector<int64_t> windowDims;
  SmallVector<WindowDimension> inferredWindow;
  // reduce_window_c1, reduce_window_c2, reduce_window_c4...reduce_window_c12,
  // reduce_window_i4...reduce_window_i7
  if (failed(verifyReduceWindowOpInputsAndInferWindow(
          location, inputTypes, initValueTypes, windowDimensions, windowStrides,
          baseDilations, windowDilations, padding, windowDims, inferredWindow)))
    return failure();

  // reduce_window_c1, reduce_window_c14...reduce_window_c16
  auto accumulatorTypesOrErr = getAccumulatorTypes(location, body);
  if (failed(accumulatorTypesOrErr))
    return failure();
  for (size_t i = 0; i < inputTypes.size(); ++i) {
    auto inputRankedType = cast<RankedTensorType>(inputs[i].getType());
    auto resultShape =
        inferWindowOutputShape(inputTypes[i].getShape(), inferredWindow);
    auto inputBounds = encodingToBounds(inputRankedType.getEncoding());
    if (inputBounds.empty()) {
      inferredReturnShapes.emplace_back(
          resultShape, (*accumulatorTypesOrErr)[i].getElementType());
    } else {
      auto resultBounds = inferWindowOutputShape(inputBounds, inferredWindow);
      inferredReturnShapes.emplace_back(
          resultShape, (*accumulatorTypesOrErr)[i].getElementType(),
          boundsToEncoding(inputRankedType.getEncoding(), resultBounds));
    }
  }

  return success();
}

LogicalResult inferBitReverseOp(std::optional<Location> location,
                                Type operandType,
                                SmallVectorImpl<Type> &inferredReturnTypes) {
  inferredReturnTypes.push_back(operandType);
  return success();
}

LogicalResult inferReverseOp(std::optional<Location> location, Type operandType,
                             SmallVectorImpl<Type> &inferredReturnTypes) {
  inferredReturnTypes.push_back(operandType);
  return success();
}

namespace {

// Checks if the vector `nums` has duplicates.
bool isUnique(ArrayRef<int64_t> nums) {
  llvm::SmallDenseSet<int64_t> dimSet;
  dimSet.reserve(nums.size());
  for (auto dim : nums) {
    if (!dimSet.insert(dim).second)
      return false;
  }
  return true;
}

// Checks if the `llvm::concat(lhsDims, rhsDims)` has duplicates.
LogicalResult checkDimsDistinct(std::optional<Location> loc,
                                ArrayRef<int64_t> lhsDims,
                                ArrayRef<int64_t> rhsDims, llvm::StringRef lhs,
                                llvm::StringRef rhs) {
  llvm::SmallDenseSet<int64_t> dimSet;
  dimSet.reserve(lhsDims.size() + rhsDims.size());
  for (auto dim : llvm::concat<const int64_t>(lhsDims, rhsDims)) {
    if (!dimSet.insert(dim).second)
      return emitOptionalError(loc, "has duplicated dimension from ", lhs,
                               " and ", rhs, ": ", dim);
  }
  return success();
}

// Checks that `dim` vector is within range [0, `upperBound`) or
//  [0, `upperBound`] if `upperBoundInclusive` is true.
LogicalResult checkDimInBounds(std::optional<Location> loc, int64_t dim,
                               int64_t upperBound, StringRef dimName,
                               StringRef upperBoundName,
                               bool upperBoundInclusive = false) {
  StringRef rangeEnd = upperBoundInclusive ? "]" : ")";
  if (dim < 0 || dim >= upperBound + (upperBoundInclusive ? 1 : 0))
    return emitOptionalError(loc, "Expects ", dimName, " to be in range [0, ",
                             upperBoundName, rangeEnd, " i.e. [0, ", upperBound,
                             rangeEnd, ". got: ", dim, ".");
  return success();
}

// Checks that `dims` vector is within range [0, `upperBound`).
LogicalResult checkDimsInBounds(std::optional<Location> loc,
                                ArrayRef<int64_t> dims, int64_t upperBound,
                                StringRef dimsName, StringRef upperBoundName) {
  for (int64_t dim : dims) {
    if (dim < 0 || dim >= upperBound)
      return emitOptionalError(loc, "Expects each element of ", dimsName,
                               " to be in range [0, ", upperBoundName,
                               ") i.e. [0, ", upperBound, "). got: ", dim, ".");
  }
  return success();
}

LogicalResult
verifyGather(std::optional<Location> location, ShapeAdaptor operandShape,
             ShapeAdaptor startIndicesShape, ShapeAdaptor sliceSizesShape,
             ArrayRef<int64_t> offsetDims, ArrayRef<int64_t> collapsedSliceDims,
             ArrayRef<int64_t> operandBatchingDims,
             ArrayRef<int64_t> startIndicesBatchingDims,
             ArrayRef<int64_t> startIndexMap, int64_t indexVectorDim) {
  // gather_c1
  int64_t impliedOperandRank = offsetDims.size() + collapsedSliceDims.size() +
                               operandBatchingDims.size();
  if (operandShape.getRank() != impliedOperandRank)
    return emitOptionalError(
        location, "offset_dims size (", offsetDims.size(),
        ") plus collapse_slice_dims size (", collapsedSliceDims.size(),
        ") plus operand_batching_dims size (", operandBatchingDims.size(),
        ") is not equal to operand rank (", operandShape.getRank(), ")");

  // gather_c2
  if (failed(checkDimInBounds(location, indexVectorDim,
                              startIndicesShape.getRank(), "index_vector_dim",
                              "rank-of('start_indices')",
                              /*upperBoundInclusive=*/true)))
    return failure();

  // gather_c3
  bool impliedTrailingDim = indexVectorDim == startIndicesShape.getRank();
  if (impliedTrailingDim || !startIndicesShape.isDynamicDim(indexVectorDim)) {
    int64_t effectiveDimSize;
    if (impliedTrailingDim)
      effectiveDimSize = 1;
    else
      effectiveDimSize = startIndicesShape.getDimSize(indexVectorDim);
    if (effectiveDimSize != static_cast<int64_t>(startIndexMap.size()))
      return emitOptionalError(
          location, "start_index_map size (", startIndexMap.size(),
          ") is not equal to size of index dimension (", indexVectorDim,
          ") of start_indices (", effectiveDimSize, ")");
  }

  // gather_c4
  if (!llvm::is_sorted(offsetDims))
    return emitOptionalError(
        location, "expects offset_dims to be sorted, got: [", offsetDims, "]");
  if (!isUnique(offsetDims))
    return emitOptionalError(
        location, "expects offset_dims to not repeat, got: [", offsetDims, "]");

  // gather_c6
  if (failed(checkDimsDistinct(location, collapsedSliceDims,
                               operandBatchingDims, "collapsed_slice_dims",
                               "operand_batching_dims")))
    return failure();

  // gather_c7
  if (!llvm::is_sorted(collapsedSliceDims))
    return emitOptionalError(
        location, "expects collapsed_slice_dims to be sorted, got: [",
        collapsedSliceDims, "]");

  // gather_c8
  if (failed(checkDimsInBounds(location, collapsedSliceDims,
                               operandShape.getRank(), "collapsed_slice_dims",
                               "rank-of('operand')")))
    return failure();

  // gather_c10
  if (!llvm::is_sorted(operandBatchingDims))
    return emitOptionalError(
        location, "expects operand_batching_dims to be sorted, got: [",
        operandBatchingDims, "]");

  // gather_c11
  if (failed(checkDimsInBounds(location, operandBatchingDims,
                               operandShape.getRank(), "operand_batching_dims",
                               "rank-of('operand')")))
    return failure();

  // gather_c13
  if (!isUnique(startIndicesBatchingDims))
    return emitOptionalError(
        location, "expects start_indices_batching_dims to not repeat, got: [",
        startIndicesBatchingDims, "]");

  // gather_c14
  if (failed(checkDimsInBounds(
          location, startIndicesBatchingDims, startIndicesShape.getRank(),
          "start_indices_batching_dims", "rank-of('start_indices')")))
    return failure();

  // gather_c15
  if (llvm::is_contained(startIndicesBatchingDims, indexVectorDim))
    return emitOptionalError(
        location,
        "expects start_indices_batching_dims not to include index_vector_dim ",
        indexVectorDim);

  // gather_c16
  if (operandBatchingDims.size() != startIndicesBatchingDims.size()) {
    return emitOptionalError(
        location, "operand_batching_dims and start_indices_batching_dims "
                  "should have the same size");
  }

  // gather_c17
  for (auto [index, dims] : llvm::enumerate(
           llvm::zip(operandBatchingDims, startIndicesBatchingDims))) {
    auto [operandDim, startIndicesDim] = dims;
    int64_t operandDimSize = operandShape.getDimSize(operandDim);
    int64_t startIndicesDimSize = startIndicesShape.getDimSize(startIndicesDim);
    if (!verifyCompatibleDims(operandDimSize, startIndicesDimSize))
      return emitOptionalError(location, "operand_batching_dims[", index,
                               "] and start_indices_batching_dims[", index,
                               "] must have compatible sizes, but got ",
                               operandDimSize, " and ", startIndicesDimSize);
  }

  // gather_c18
  if (failed(checkDimsDistinct(location, startIndexMap, operandBatchingDims,
                               "start_index_map", "operand_batching_dims")))
    return failure();

  // gather_c19
  if (failed(checkDimsInBounds(location, startIndexMap, operandShape.getRank(),
                               "start_index_map", "rank-of('operand')")))
    return failure();

  // gather_i9
  if (sliceSizesShape.getRank() != 1)
    return emitOptionalError(location, "slice_sizes.rank != 1 (got ",
                             sliceSizesShape.getRank(), ')');
  int64_t sliceSize = sliceSizesShape.getNumElements();

  // gather_c20
  if (sliceSize != operandShape.getRank())
    return emitOptionalError(location, "slice_sizes size (", sliceSize,
                             ") not equal to operand rank (",
                             operandShape.getRank(), ")");

  return success();
}

template <typename dimTy>
void inferGatherShape(int64_t resultRank,
                      llvm::function_ref<dimTy(int64_t)> getStartIndicesDim,
                      llvm::function_ref<dimTy(int64_t)> getSliceDim,
                      ArrayRef<int64_t> offsetDims,
                      ArrayRef<int64_t> collapsedSliceDims,
                      ArrayRef<int64_t> operandBatchingDims,
                      int64_t indexVectorDim, SmallVectorImpl<dimTy> &shape) {
  // We don't necessarily know the rank of sliceSizes, but we do know that it
  // can't be larger than the highest collapsed/batch dimension. So go through
  // those and populate the leading dimensions of adjustedSliceSizes. The
  // trailing dimensions can just be adjusted by an offset.
  auto collapsedAndBatchDims =
      llvm::concat<const int64_t>(collapsedSliceDims, operandBatchingDims);
  auto maxOperandDimIt = std::max_element(collapsedAndBatchDims.begin(),
                                          collapsedAndBatchDims.end());
  int64_t maxOperandDim = -1;
  if (maxOperandDimIt != collapsedAndBatchDims.end())
    maxOperandDim = *maxOperandDimIt;

  SmallVector<dimTy> adjustedSliceSizePrefix;
  for (int dimIndex = 0; dimIndex <= maxOperandDim; ++dimIndex) {
    if (llvm::is_contained(collapsedAndBatchDims, dimIndex))
      continue;
    adjustedSliceSizePrefix.push_back(getSliceDim(dimIndex));
  }
  auto getAdjustedSliceDim = [&](int64_t index) -> dimTy {
    if (index < static_cast<int64_t>(adjustedSliceSizePrefix.size()))
      return adjustedSliceSizePrefix[index];
    return getSliceDim(index + collapsedSliceDims.size() +
                       operandBatchingDims.size());
  };

  // Dimensions in the output that aren't offset dimensions are called batch
  // dimensions.
  SmallVector<int64_t> batchDims;
  for (int dim = 0; dim < resultRank; ++dim)
    if (!llvm::is_contained(offsetDims, dim))
      batchDims.push_back(dim);

  for (int i = 0; i < resultRank; ++i) {
    const auto *offsetDimsIt =
        std::find(offsetDims.begin(), offsetDims.end(), i);
    if (offsetDimsIt != offsetDims.end()) {
      auto index = std::distance(offsetDims.begin(), offsetDimsIt);
      shape.push_back(getAdjustedSliceDim(index));
      continue;
    }
    auto *batchDimsIt = std::find(batchDims.begin(), batchDims.end(), i);
    assert(batchDimsIt != batchDims.end());
    auto index = std::distance(batchDims.begin(), batchDimsIt);
    // This can never run into the special case where start_indices gets
    // implicitly expanded with a trailing 1 if
    // index_vector_dim = start_indices.rank because then index would equal
    // index_vector_dim, which means we'd be looking at index+1, which would be
    // out of bounds anyway.
    if (index >= indexVectorDim)
      ++index;
    shape.push_back(getStartIndicesDim(index));
  }
}

LogicalResult inferGatherReturnTypeComponents(
    std::optional<Location> location, ShapeAdaptor operandShape,
    Value startIndices, llvm::function_ref<int64_t(int64_t)> getSliceDim,
    ArrayRef<int64_t> offsetDims, ArrayRef<int64_t> collapsedSliceDims,
    ArrayRef<int64_t> operandBatchingDims, int64_t indexVectorDim,
    SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  Type elementType = operandShape.getElementType();
  ShapeAdaptor startIndicesShape(startIndices.getType());

  int64_t startIndicesRank = startIndicesShape.getRank();
  // If index_vector_dim == start_indices.rank, then an implicit trailing 1 is
  // appended to start_indices shape.
  if (indexVectorDim == startIndicesRank)
    ++startIndicesRank;
  int64_t resultRank = offsetDims.size() + startIndicesRank - 1;
  // gather_c5
  if (failed(checkDimsInBounds(location, offsetDims, resultRank, "offset_dims",
                               "implied-result-rank")))
    return failure();

  auto getStartIndicesDim = [&](int64_t index) {
    return startIndicesShape.getDimSize(index);
  };

  // gather_c22, gather_c23
  SmallVector<int64_t> shape;
  inferGatherShape<int64_t>(resultRank, getStartIndicesDim, getSliceDim,
                            offsetDims, collapsedSliceDims, operandBatchingDims,
                            indexVectorDim, shape);

  // The dimension sizes of result, corresponding to offset dimensions, depend
  // on attributes (like `collapsed_slice_dims` and `slice_sizes`) and hence are
  // always static. Whereas, the dimension sizes of result, corresponding to
  // batch dimensions, depends on input `start_indices` and could be dynamic.
  // The corresponding bounds, in that case, are propagated from the
  // `start_indices`.
  Attribute encoding =
      cast<RankedTensorType>(startIndices.getType()).getEncoding();
  ArrayRef<int64_t> startIndicesBounds = encodingToBounds(encoding);
  SmallVector<int64_t> inferredBounds(resultRank, ShapedType::kDynamic);
  if (!startIndicesBounds.empty()) {
    llvm::BitVector isOffsetDim(resultRank);
    for (auto offsetDim : offsetDims)
      isOffsetDim.set(offsetDim);

    int64_t startIndicesDim = 0;
    for (int resultDim = 0; resultDim < resultRank; ++resultDim) {
      if (isOffsetDim.test(resultDim))
        continue;

      if (startIndicesDim == indexVectorDim)
        ++startIndicesDim;
      inferredBounds[resultDim] = startIndicesBounds[startIndicesDim++];
    }
  }

  inferredReturnShapes.emplace_back(shape, elementType,
                                    boundsToEncoding(encoding, inferredBounds));
  return success();
}

} // namespace

void reifyGatherDimSizes(int64_t resultRank,
                         llvm::function_ref<Value(int64_t)> getStartIndicesDim,
                         llvm::function_ref<Value(int64_t)> getSliceDim,
                         ArrayRef<int64_t> offsetDims,
                         ArrayRef<int64_t> collapsedSliceDims,
                         ArrayRef<int64_t> operandBatchingDims,
                         int64_t indexVectorDim,
                         SmallVectorImpl<Value> &shape) {
  inferGatherShape<Value>(resultRank, getStartIndicesDim, getSliceDim,
                          offsetDims, collapsedSliceDims, operandBatchingDims,
                          indexVectorDim, shape);
}

LogicalResult inferGatherOp(
    std::optional<Location> location, Value operand, Value startIndices,
    ArrayRef<int64_t> offsetDims, ArrayRef<int64_t> collapsedSliceDims,
    ArrayRef<int64_t> operandBatchingDims,
    ArrayRef<int64_t> startIndicesBatchingDims, ArrayRef<int64_t> startIndexMap,
    int64_t indexVectorDim, ArrayRef<int64_t> sliceSizes,
    SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  ShapeAdaptor operandShape(operand.getType());
  ShapeAdaptor startIndicesShape(startIndices.getType());
  SmallVector<int64_t, 1> ssShape{static_cast<int64_t>(sliceSizes.size())};
  ShapedTypeComponents ssSTC{ssShape};
  ShapeAdaptor sliceSizesShape(ssSTC);

  // For some reason the getType call is necessary here
  if (failed(verifyGather(location,
                          /*operandShape=*/operandShape,
                          /*startIndicesShape=*/startIndicesShape,
                          /*sliceSizesShape=*/sliceSizesShape, offsetDims,
                          collapsedSliceDims, operandBatchingDims,
                          startIndicesBatchingDims, startIndexMap,
                          indexVectorDim)))
    return failure();

  auto checkSliceSizesOne = [&](ArrayRef<int64_t> dims, StringRef name) {
    for (auto dim : dims) {
      int64_t sliceDimSize = sliceSizes[dim];
      if (sliceDimSize > 1)
        return emitOptionalError(
            location, "Expects that for each dim in ", name,
            ", slice_sizes[dim] should be <= 1, but got ", sliceDimSize);
    }
    return success();
  };

  // gather_c9
  if (failed(checkSliceSizesOne(collapsedSliceDims, "collapsed_slice_dims")))
    return failure();

  // gather_c12
  if (failed(checkSliceSizesOne(operandBatchingDims, "operand_batching_dims")))
    return failure();

  // gather_c21
  for (auto [index, size] : llvm::enumerate(sliceSizes)) {
    if (size < 0 || (!operandShape.isDynamicDim(index) &&
                     size > operandShape.getDimSize(index))) {
      return emitOptionalError(location, "slice size (", size,
                               ") is out of bounds for operand dimension (",
                               operandShape.getDimSize(index), ") at index ",
                               index);
    }
  }

  auto getSliceDim = [&sliceSizes](int64_t index) -> int64_t {
    return sliceSizes[index];
  };

  // gather_c5, gather_c22
  return inferGatherReturnTypeComponents(
      location, operandShape, startIndices, getSliceDim, offsetDims,
      collapsedSliceDims, operandBatchingDims, indexVectorDim,
      inferredReturnShapes);
}

LogicalResult inferScatterOp(std::optional<Location> location,
                             ValueRange inputs, Region &updateComputation,
                             SmallVectorImpl<Type> &inferredReturnTypes) {
  // scatter_c24, scatter_c25
  auto accumulatorTypesOrErr = getAccumulatorTypes(location, updateComputation);
  if (failed(accumulatorTypesOrErr))
    return failure();
  for (uint64_t inputIdx = 0; inputIdx < inputs.size(); ++inputIdx) {
    auto inputShapedTy = cast<ShapedType>(inputs[inputIdx].getType());
    inferredReturnTypes.push_back(getSameShapeTensorType(
        inputShapedTy, (*accumulatorTypesOrErr)[inputIdx].getElementType()));
  }
  return success();
}

LogicalResult
inferSelectOp(std::optional<Location> location, Value pred, Value onTrue,
              Value onFalse,
              SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  auto predType = cast<ShapedType>(pred.getType());
  auto trueType = cast<ShapedType>(onTrue.getType());
  auto falseType = cast<ShapedType>(onFalse.getType());

  // select_c2
  if (!compatibleShapeAndElementType(trueType, falseType))
    return emitOptionalError(
        location, "requires compatible types for non-predicate operands");

  // select_c1
  bool predCannotBeScalar = predType.getRank() != 0;
  if (predCannotBeScalar)
    if (failed(verifyCompatibleShape(predType, trueType)))
      return emitOptionalError(location,
                               "requires the same shape for all operands");

  // select_c2
  SmallVector<Type> inferredReturnTypes;
  return inferMostSpecificTypeComponents(location, {trueType, falseType},
                                         inferredReturnShapes);
}

LogicalResult inferSetDimensionSizeOp(
    HloDialectInterface *dialect, std::optional<Location> location,
    Type operandType, Value size, int64_t dimension,
    SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  auto sizeType = cast<RankedTensorType>(size.getType());
  if (sizeType.getRank() != 0)
    return emitOptionalError(location, "size operand should be of rank-0");
  if (failed(verifyDimInBounds(location, cast<ShapedType>(operandType),
                               dimension)))
    return failure();

  auto inputType = cast<RankedTensorType>(operandType);
  int64_t rank = inputType.getRank();
  if (dimension < 0 || dimension >= rank)
    return emitOptionalError(location, "expects dimension to be in range [0, ",
                             rank, "); got: [", dimension, "].");

  auto shape = llvm::to_vector<4>(inputType.getShape());
  llvm::SmallVector<int64_t, 4> bounds(rank, ShapedType::kDynamic);
  ArrayRef<int64_t> inputBounds = encodingToBounds(inputType.getEncoding());
  if (!inputBounds.empty())
    bounds = llvm::to_vector<4>(inputBounds);

  if (!hlo::isDynamicDimSize(shape[dimension]))
    bounds[dimension] = shape[dimension];
  shape[dimension] = ShapedType::kDynamic;

  DenseIntElementsAttr sizeAttr;
  if (matchPattern(size, m_Constant(&sizeAttr))) {
    int64_t splat =
        sizeAttr.getSplatValue<IntegerAttr>().getValue().getSExtValue();
    if (splat == bounds[dimension]) {
      shape[dimension] = splat;
      bounds[dimension] = ShapedType::kDynamic;
    }
  }

  if (llvm::all_of(bounds, [&](auto b) { return isDynamicDimSize(b); }))
    inferredReturnShapes.emplace_back(shape, inputType.getElementType());
  else
    inferredReturnShapes.emplace_back(shape, inputType.getElementType(),
                                      dialect->createTypeExtensions(bounds));
  return success();
}

LogicalResult inferSliceOp(std::optional<Location> location, Type operandType,
                           ArrayRef<int64_t> startIndices,
                           ArrayRef<int64_t> limitIndices,
                           ArrayRef<int64_t> strides,
                           SmallVectorImpl<Type> &inferredReturnTypes) {
  auto rankedTy = cast<RankedTensorType>(operandType);

  // slice_c2
  int64_t rank = rankedTy.getRank();
  if (static_cast<int64_t>(startIndices.size()) != rank)
    return emitOptionalError(
        location, "the number of elements in start_indices (",
        startIndices.size(), ") does not match the rank of the operand (", rank,
        ")");

  ArrayRef<int64_t> inputBounds = encodingToBounds(rankedTy.getEncoding());
  SmallVector<int64_t> shape(rank, ShapedType::kDynamic);
  SmallVector<int64_t> resultBounds(inputBounds.size(), ShapedType::kDynamic);

  for (int64_t i = 0, e = rank; i != e; i++) {
    // slice_c3
    if (startIndices[i] < 0)
      return emitOptionalError(location, "negative start index ",
                               startIndices[i], " in dimension ", i);

    bool isStaticDim = isStaticDimSize(rankedTy.getDimSize(i));
    bool isStaticBound =
        !inputBounds.empty() && isStaticDimSize(inputBounds[i]);
    if (isStaticDim || isStaticBound) {
      int64_t operandSizeOrBound =
          isStaticDim ? rankedTy.getDimSize(i) : inputBounds[i];
      StringRef sizeOrBound = isStaticDim ? "size" : "bound";
      // slice_c3
      if (limitIndices[i] > operandSizeOrBound)
        return emitOptionalError(location, "limit index ", limitIndices[i],
                                 " is larger than dimension ", sizeOrBound, " ",
                                 operandSizeOrBound, " in dimension ", i);
    }

    // slice_c3
    if (startIndices[i] > limitIndices[i])
      return emitOptionalError(location, "start index ", startIndices[i],
                               " is larger than limit index ", limitIndices[i],
                               " in dimension ", i);
    // slice_c4
    if (strides[i] <= 0)
      return emitOptionalError(location, "stride must be positive but got ",
                               strides[i], " in dimension ", i);

    // slice_c5
    shape[i] = static_cast<int64_t>(
        llvm::divideCeil(limitIndices[i] - startIndices[i], strides[i]));
  }

  // slice_c1
  inferredReturnTypes.push_back(RankedTensorType::get(
      shape, rankedTy.getElementType(),
      boundsToEncoding(rankedTy.getEncoding(), resultBounds)));
  return success();
}

LogicalResult
inferSortOp(std::optional<Location>, ValueRange inputs,
            SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  // sort_c2
  for (auto resultType : inputs.getTypes()) {
    auto rankedResult = cast<RankedTensorType>(resultType);
    inferredReturnShapes.emplace_back(rankedResult.getShape(),
                                      rankedResult.getElementType(),
                                      rankedResult.getEncoding());
  }
  return success();
}

LogicalResult inferTransposeOp(std::optional<Location> loc, Value operand,
                               ArrayRef<int64_t> permutation,
                               SmallVectorImpl<Type> &inferredReturnTypes) {
  auto type = operand.getType();
  auto rankedTy = cast<RankedTensorType>(type);
  int64_t rank = rankedTy.getRank();
  if (static_cast<int64_t>(permutation.size()) != rank)
    return emitOptionalError(loc, "TransposeOp operand rank ", rank,
                             " does not match permutation size ",
                             permutation.size());

  SmallVector<int64_t> range(rank);
  std::iota(range.begin(), range.end(), 0);
  if (!std::is_permutation(range.begin(), range.end(), permutation.begin()))
    return emitOptionalError(loc,
                             "attribute permutation must be a permutation"
                             " of [",
                             range, "] but got ", permutation);

  ArrayRef<int64_t> inputBounds = encodingToBounds(rankedTy.getEncoding());
  SmallVector<int64_t> resultShape;
  SmallVector<int64_t> resultBounds;
  ArrayRef<int64_t> inputShape = rankedTy.getShape();
  for (int64_t dim : permutation) {
    resultShape.push_back(inputShape[dim]);
    if (!inputBounds.empty())
      resultBounds.push_back(inputBounds[dim]);
  }

  inferredReturnTypes.push_back(RankedTensorType::get(
      resultShape, rankedTy.getElementType(),
      boundsToEncoding(rankedTy.getEncoding(), resultBounds)));
  return success();
}

LogicalResult inferTupleOp(MLIRContext *context, std::optional<Location>,
                           ValueRange val,
                           SmallVectorImpl<Type> &inferredReturnTypes) {
  // tuple_c1
  inferredReturnTypes.push_back(TupleType::get(context, val.getTypes()));
  return success();
}

LogicalResult inferWhileOp(std::optional<Location>, ValueRange operand,
                           SmallVectorImpl<Type> &inferredReturnTypes) {
  // while_c3
  for (const auto &resultType : operand.getType())
    inferredReturnTypes.push_back(resultType);
  return success();
}

//===----------------------------------------------------------------------===//
// Verifiers for ops.
//===----------------------------------------------------------------------===//

namespace {

unsigned getBitWidth(Type type) {
  if (auto pfType = dyn_cast<prime_ir::field::PrimeFieldType>(type)) {
    return pfType.getStorageBitWidth();
  }
  if (auto efType = dyn_cast<prime_ir::field::ExtensionFieldType>(type)) {
    return efType.getStorageBitWidth();
  }
  return type.getIntOrFloatBitWidth();
}

template <typename T>
bool matchesType(Type a, Type b) {
  return isa<T>(a) && isa<T>(b);
}

// Returns true if the element-type of type1 can be promoted to that of type2.
// An element-type 'x' is promotable to element-type 'y' if they have the same
// base type and bitwidth(x) <= bitwidth(y).
bool isPromotableElementType(Type type1, Type type2) {
  auto tensorTy1 = dyn_cast<ShapedType>(type1);
  auto tensorTy2 = dyn_cast<ShapedType>(type2);

  if (!tensorTy1 || !tensorTy2)
    return false;

  Type tensorEl1 = tensorTy1.getElementType();
  Type tensorEl2 = tensorTy2.getElementType();

  bool isSameType =
      matchesType<IntegerType>(tensorEl1, tensorEl2) ||
      matchesType<prime_ir::field::PrimeFieldType>(tensorEl1, tensorEl2) ||
      matchesType<prime_ir::field::ExtensionFieldType>(tensorEl1, tensorEl2);

  if (!isSameType)
    return false;

  return getBitWidth(tensorEl1) <= getBitWidth(tensorEl2);
}

// If the shape operand is constant, checks that it is compatible with the
// result's shape. Emits an error if the shapes are incompatible.
LogicalResult verifyShapeOperandIsCompatibleWithResultType(
    std::optional<Location> loc, Value shapeOperand, Type resultType) {
  if (SmallVector<int64_t> shape;
      succeeded(matchInts(shapeOperand, shape)) &&
      !isCompatibleForHloTypeInference(shape, resultType)) {
    std::string str;
    llvm::raw_string_ostream os(str);
    llvm::interleaveComma(shape, os, [&](int64_t i) { os << i; });
    return emitOptionalError(loc, "output shape [", os.str(),
                             "] is incompatible with return type of operation ",
                             resultType);
  }
  return success();
}

LogicalResult verifyReducerShape(std::optional<Location> loc, Block &block,
                                 ArrayRef<ShapedType> inputTypes,
                                 ArrayRef<ShapedType> initValueTypes,
                                 ArrayRef<int64_t> allowedDimensions) {
  int64_t numInputs = inputTypes.size();

  // all_reduce_c5, reduce_c6, reduce_scatter_c7, reduce_window_c13,
  // scatter_c23, select_and_scatter_c10
  if (static_cast<int64_t>(block.getArguments().size()) != numInputs * 2)
    return emitOptionalError(loc, "Reduction-region must take ", numInputs * 2,
                             " parameters, but takes ",
                             block.getArguments().size(), " parameter(s)");

  // all_reduce_c5, reduce_c6, reduce_scatter_c7, reduce_window_c13,
  // scatter_c23, select_and_scatter_c10
  if (block.getTerminator()->getOperands().empty())
    return emitOptionalError(
        loc, "The reduction-region expected to return some value(s)");

  // all_reduce_c5, reduce_c6, reduce_scatter_c7, reduce_window_c13,
  // scatter_c23, select_and_scatter_c10
  if (static_cast<int64_t>(block.getTerminator()->getOperands().size()) !=
      numInputs)
    return emitOptionalError(loc, "Reduction-region here must produce ",
                             numInputs, " tensors, but produces ",
                             block.getTerminator()->getOperands().size(),
                             " instead");

  // all_reduce_c5, reduce_c6, reduce_scatter_c7, reduce_window_c13,
  // scatter_c23, select_and_scatter_c10
  SmallVector<ShapedType> accumulatorSubShapes;
  for (Value retOperand : block.getTerminator()->getOperands()) {
    auto shapedTy = dyn_cast<ShapedType>(retOperand.getType());
    if (!shapedTy)
      return emitOptionalError(loc,
                               "Reduction-region here must produce "
                               "tensor-typed result(s), but produces ",
                               retOperand.getType(), " instead");

    accumulatorSubShapes.push_back(shapedTy);
  }

  for (int64_t inputIdx = 0; inputIdx < numInputs; ++inputIdx) {
    // all_reduce_c5, reduce_c2, reduce_scatter_c7, reduce_window_c13,
    // scatter_c23, select_and_scatter_c10
    if (!compatibleShapeAndElementType(accumulatorSubShapes[inputIdx],
                                       block.getArgument(inputIdx).getType()))
      return emitOptionalError(
          loc, "The type of reduction-region's parameter at index ", inputIdx,
          " is different than the corresponding result type: ",
          block.getArgument(inputIdx).getType(), " vs ",
          accumulatorSubShapes[inputIdx]);

    // all_reduce_c5, reduce_c2, reduce_scatter_c7, reduce_window_c13,
    // scatter_c23, select_and_scatter_c3, select_and_scatter_c10
    if (!compatibleShapeAndElementType(
            accumulatorSubShapes[inputIdx],
            block.getArgument(numInputs + inputIdx).getType()))
      return emitOptionalError(
          loc, "The type of reduction-region's parameter at index ",
          numInputs + inputIdx,
          " is different than the corresponding result type: ",
          block.getArgument(numInputs + inputIdx).getType(), " vs ",
          accumulatorSubShapes[inputIdx]);

    // all_reduce_c5, reduce_c6, reduce_scatter_c7, reduce_window_c13,
    // reduce_window_i2, scatter_c6, scatter_c23, select_and_scatter_c10
    if (failed(verifyCompatibleShape(initValueTypes[inputIdx],
                                     accumulatorSubShapes[inputIdx])))
      return emitOptionalError(
          loc, "The shape of reduction-region's result type at index ",
          inputIdx, " differs from the op's corresponding init-value type: ",
          accumulatorSubShapes[inputIdx], " vs ", initValueTypes[inputIdx]);

    if (!isPromotableElementType(initValueTypes[inputIdx],
                                 accumulatorSubShapes[inputIdx]))
      return emitOptionalError(
          loc, "The element-type of reduction-region's result type at index ",
          inputIdx,
          " is expected to be promotable from the op's corresponding "
          "init-value element-type: ",
          accumulatorSubShapes[inputIdx], " vs ", initValueTypes[inputIdx]);

    // reduce_c6, reduce_window_c3, scatter_c6, scatter_c23,
    // select_and_scatter_c10
    if (!isPromotableElementType(
            inputTypes[inputIdx],
            block.getArgument(numInputs + inputIdx).getType()))
      return emitOptionalError(
          loc, "The element-type of reduction-region's argument at index ",
          numInputs + inputIdx, " is expected to be promotable from ",
          inputTypes[inputIdx].getElementType(), ", but got ",
          getElementTypeOrSelf(
              block.getArgument(numInputs + inputIdx).getType()));

    Type blockArgType = block.getArgument(numInputs + inputIdx).getType();
    auto blockArgTensorTy = cast<RankedTensorType>(blockArgType);

    auto argShape = blockArgTensorTy.getShape();
    // reduce_c6, reduce_window_c13, select_and_scatter_c10
    if (argShape.size() > allowedDimensions.size())
      return emitOptionalError(
          loc, "The rank of reduction-region's argument at index ",
          numInputs + inputIdx,
          " is expected to be <= ", allowedDimensions.size(), ", got ",
          argShape.size());

    int64_t argShapeIdx = 0;
    for (int64_t outputShapeIdx = 0;
         outputShapeIdx < static_cast<int64_t>(allowedDimensions.size()) &&
         argShapeIdx < static_cast<int64_t>(argShape.size());
         outputShapeIdx++)
      if (verifyCompatibleDims(allowedDimensions[outputShapeIdx],
                               argShape[argShapeIdx]))
        argShapeIdx++;

    // reduce_c6, reduce_window_c13
    if (argShapeIdx != static_cast<int64_t>(argShape.size()))
      return emitOptionalError(
          loc, "The shape of reduction-region's argument at index ",
          numInputs + inputIdx,
          " is not compatible with that of reduce-op's input-parameter "
          "at index ",
          inputIdx);
  }

  return success();
}

LogicalResult validateScatterDimensionNumbers(
    ShapedType operandType, ArrayRef<int64_t> scatterIndicesShape,
    ShapedType updateType, ArrayRef<int64_t> updateWindowDims,
    ArrayRef<int64_t> insertedWindowDims, ArrayRef<int64_t> inputBatchingDims,
    ArrayRef<int64_t> scatterIndicesBatchingDims,
    ArrayRef<int64_t> scatterDimsToOperandDims, int64_t indexVectorDim,
    std::optional<Location> loc) {
  // scatter_c2
  auto windowSize = updateWindowDims.size() + insertedWindowDims.size() +
                    inputBatchingDims.size();
  if (operandType.getRank() != static_cast<int64_t>(windowSize))
    return emitOptionalError(loc,
                             "Expects rank-of operand to match "
                             "size-of('update_window_dims') + "
                             "size-of('inserted_window_dims') + "
                             "size-of('input_batching_dims') i.e. ",
                             windowSize, " but got ", operandType.getRank(),
                             ".");

  // scatter_c7
  if (!llvm::is_sorted(updateWindowDims))
    return emitOptionalError(loc,
                             "Expects update_window_dims to be sorted; got: [",
                             updateWindowDims, "].");
  if (!isUnique(updateWindowDims))
    return emitOptionalError(loc,
                             "Expects update_window_dims to not repeat; got: [",
                             updateWindowDims, "].");

  // scatter_c8
  if (failed(checkDimsInBounds(loc, updateWindowDims, updateType.getRank(),
                               "update_window_dims", "rank-of('updates')")))
    return failure();

  // scatter_c9
  if (failed(checkDimsDistinct(loc, insertedWindowDims, inputBatchingDims,
                               "inserted_window_dims", "input_batching_dims")))
    return failure();

  // scatter_c10
  if (!llvm::is_sorted(insertedWindowDims))
    return emitOptionalError(
        loc, "Expects inserted_window_dims to be sorted; got: [",
        insertedWindowDims, "].");

  // scatter_c11
  if (failed(checkDimsInBounds(loc, insertedWindowDims, operandType.getRank(),
                               "inserted_window_dims", "rank-of('operand')")))
    return failure();

  // scatter_c12
  if (!llvm::is_sorted(inputBatchingDims))
    return emitOptionalError(loc,
                             "Expects input_batching_dims to be sorted; got: [",
                             inputBatchingDims, "].");

  // scatter_c13
  if (failed(checkDimsInBounds(loc, inputBatchingDims, operandType.getRank(),
                               "input_batching_dims", "rank-of('operand')")))
    return failure();

  // scatter_c14
  if (!isUnique(scatterIndicesBatchingDims))
    return emitOptionalError(
        loc, "Expects scatter_indices_batching_dims to not repeat; got: [",
        scatterIndicesBatchingDims, "].");

  // scatter_c15
  if (failed(checkDimsInBounds(
          loc, scatterIndicesBatchingDims, scatterIndicesShape.size(),
          "scatter_indices_batching_dims", "rank-of('scatter_indices')")))
    return failure();

  // scatter_c16
  if (llvm::is_contained(scatterIndicesBatchingDims, indexVectorDim))
    return emitOptionalError(loc,
                             "expects scatter_indices_batching_dims not to "
                             "include index_vector_dim ",
                             indexVectorDim, ".");

  // scatter_c17
  if (inputBatchingDims.size() != scatterIndicesBatchingDims.size()) {
    return emitOptionalError(
        loc, "input_batching_dims and scatter_indices_batching_dims "
             "should have the same size.");
  }

  // scatter_c18
  for (auto [index, dims] : llvm::enumerate(
           llvm::zip(inputBatchingDims, scatterIndicesBatchingDims))) {
    auto [inputDim, scatterIndicesDim] = dims;
    int64_t inputDimSize = operandType.getDimSize(inputDim);
    int64_t scatterIndicesDimSize = scatterIndicesShape[scatterIndicesDim];
    if (!verifyCompatibleDims(inputDimSize, scatterIndicesDimSize))
      return emitOptionalError(loc, "input_batching_dims[", index,
                               "] and scatter_indices_batching_dims[", index,
                               "] must have compatible sizes, but got ",
                               inputDimSize, " and ", scatterIndicesDimSize,
                               ".");
  }

  // scatter_c19
  if (indexVectorDim == static_cast<int64_t>(scatterIndicesShape.size()) &&
      scatterDimsToOperandDims.size() != 1)
    return emitOptionalError(
        loc, "Scatter op has ", scatterDimsToOperandDims.size(),
        " elements in scatter_dims_to_operand_dims and "
        "the bound of dimension index_vector_dim=",
        indexVectorDim,
        " of scatter_indices is 1. These two numbers must be equal.");

  if (!isDynamicDimSize(scatterIndicesShape[indexVectorDim]) &&
      static_cast<int64_t>(scatterDimsToOperandDims.size()) !=
          scatterIndicesShape[indexVectorDim])
    return emitOptionalError(loc, "Scatter op has ",
                             scatterDimsToOperandDims.size(),
                             " elements in scatter_dims_to_operand_dims and "
                             "the bound of dimension index_vector_dim=",
                             indexVectorDim, " of scatter_indices is ",
                             scatterIndicesShape[indexVectorDim],
                             ". These two numbers must be equal.");

  // scatter_c20
  if (failed(checkDimsDistinct(loc, scatterDimsToOperandDims, inputBatchingDims,
                               "scatter_dims_to_operand_dims",
                               "input_batching_dims")))
    return failure();

  // scatter_c21
  if (failed(checkDimsInBounds(
          loc, scatterDimsToOperandDims, operandType.getRank(),
          "scatter_dims_to_operand_dims", "rank-of('operand')")))
    return failure();

  return success();
}

} // namespace

LogicalResult verifyAddOp(std::optional<Location> location, Operation *op,
                          Type lhsType, Type rhsType, Type resultType) {
  llvm::SmallVector<Type, 3> typeEntries{lhsType, rhsType, resultType};

  if (getElementTypeOrSelf(lhsType) != getElementTypeOrSelf(rhsType) ||
      getElementTypeOrSelf(lhsType) != getElementTypeOrSelf(resultType))
    return emitOptionalError(
        location,
        "op requires the same element type for all operands and results");

  return success();
}

LogicalResult verifyBitcastConvertOp(std::optional<Location> location,
                                     Value operand, Value result) {
  auto operandShapedType = cast<ShapedType>(operand.getType());
  auto targetShapedType = cast<ShapedType>(result.getType());

  // bitcast_convert_c2
  auto targetElt = targetShapedType.getElementType();
  auto operandElt = operandShapedType.getElementType();

  auto targetEltBitWidth = getBitWidth(targetElt);
  auto operandEltBitWidth = getBitWidth(operandElt);

  auto operandType = cast<RankedTensorType>(operandShapedType);
  auto targetType = cast<RankedTensorType>(targetShapedType);

  auto targetShape = targetType.getShape();
  auto operandShape = operandType.getShape();
  ArrayRef<int64_t> smallerEltShape, biggerEltShape;
  if (operandEltBitWidth < targetEltBitWidth) {
    smallerEltShape = operandShape;
    biggerEltShape = targetShape;
  } else {
    smallerEltShape = targetShape;
    biggerEltShape = operandShape;
  }

  ArrayRef<int64_t> smallerEltPrefix;
  auto smallerEltBitWidth = std::min(targetEltBitWidth, operandEltBitWidth);
  auto biggerEltBitWidth = std::max(targetEltBitWidth, operandEltBitWidth);
  // bitcast_convert_c1
  if (operandEltBitWidth != targetEltBitWidth) {
    if (smallerEltShape.size() != biggerEltShape.size() + 1) {
      return emitOptionalError(
          location, "rank of smaller element type (", smallerEltShape.size(),
          ") should be 1 more than rank of larger element type (",
          biggerEltShape.size(), "), but ", smallerEltShape.size(),
          " != ", biggerEltShape.size(), " + 1.");
    }
    smallerEltPrefix = smallerEltShape.drop_back();
    if (!isDynamicDimSize(smallerEltShape.back()) &&
        smallerEltShape.back() * smallerEltBitWidth != biggerEltBitWidth) {
      return emitOptionalError(
          location, "requires compatible bit widths. ", "Got: ", operandType,
          " and ", targetType, ", but ", smallerEltBitWidth, " * ",
          smallerEltShape.back(), " != ", biggerEltBitWidth, ".");
    }
  } else {
    smallerEltPrefix = smallerEltShape;
  }

  for (auto [targetDim, operandDim] :
       llvm::zip(smallerEltPrefix, biggerEltShape)) {
    // bitcast_convert_c1
    if (!verifyCompatibleDims(targetDim, operandDim))
      return emitOptionalError(location,
                               "operand and result shapes must match except "
                               "for the innermost dimension of the shape with "
                               "the smaller element type. Got: ",
                               operandType, " and ", targetType, ".");
  }

  return success();
}

LogicalResult verifyBroadcastInDimOp(std::optional<Location> location,
                                     Value operand,
                                     ArrayRef<int64_t> broadcastDimensions,
                                     Value result) {
  // broadcast_in_dim_c1
  auto operandType = cast<RankedTensorType>(operand.getType());

  // broadcast_in_dim_c2
  auto dimensionsSize = broadcastDimensions.size();
  auto operandRank = operandType.getRank();
  if (static_cast<int64_t>(dimensionsSize) != operandRank)
    return emitOptionalError(location, "broadcast_dimensions size (",
                             dimensionsSize, ") does not match operand rank (",
                             operandRank, ")");

  // broadcast_in_dim_c4
  if (!isUnique(broadcastDimensions))
    return emitOptionalError(location,
                             "broadcast_dimensions should not have duplicates");

  auto resultType = cast<RankedTensorType>(result.getType());
  auto resultRank = resultType.getRank();
  for (size_t i = 0; i != dimensionsSize; ++i) {
    auto dimIndex = broadcastDimensions[i];
    // broadcast_in_dim_c3
    if (dimIndex < 0 || dimIndex >= resultRank)
      return emitOptionalError(location,
                               "broadcast_dimensions contains invalid value ",
                               dimIndex, " for result with rank ", resultRank);

    if (!operandType.isDynamicDim(i)) {
      auto dimSize = operandType.getDimSize(i);
      auto resultDimSize = resultType.getDimSize(dimIndex);
      // broadcast_in_dim_c5
      if (dimSize != 1 && dimSize != resultDimSize)
        return emitOptionalError(
            location, "size of operand dimension ", i, " (", dimSize,
            ") is not equal to 1 or size of result dimension ", dimIndex, " (",
            resultDimSize, ")");
    }
  }

  return success();
}

LogicalResult verifyDynamicBroadcastInDimOp(
    std::optional<Location> location, Value operand, Value outputDimensions,
    ArrayRef<int64_t> broadcastDimensions,
    std::optional<ArrayRef<int64_t>> knownExpandingDimensions,
    std::optional<ArrayRef<int64_t>> knownNonexpandingDimensions,
    Value result) {
  auto operandType = cast<RankedTensorType>(operand.getType());
  auto resultType = cast<RankedTensorType>(result.getType());
  auto resultRank = resultType.getRank();
  auto bcastDimensions = broadcastDimensions;
  int64_t bcastDimensionsSize = bcastDimensions.size();
  auto operandRank = operandType.getRank();

  // dynamic_broadcast_in_dim_c1
  if (!isCompatibleElementTypeForHloTypeInference(operand.getType(),
                                                  result.getType()))
    return emitOptionalError(
        location,
        "expects operand and result to have compatible element type. Got: ",
        operand.getType(), " and ", result.getType());

  // dynamic_broadcast_in_dim_c2
  if (bcastDimensionsSize != operandRank)
    return emitOptionalError(
        location, "broadcast_dimensions size (", bcastDimensionsSize,
        ") does not match operand rank (", operandRank, ")");

  // dynamic_broadcast_in_dim_c3
  if (resultRank < operandRank)
    return emitOptionalError(location, "result rank (", resultRank,
                             ") is less than operand rank (", operandRank, ")");

  // dynamic_broadcast_in_dim_c4
  if (!isUnique(broadcastDimensions))
    return emitOptionalError(location,
                             "broadcast_dimensions should not have duplicates");

  // dynamic_broadcast_in_dim_c5
  for (int i = 0; i != bcastDimensionsSize; ++i) {
    auto dimIndex = bcastDimensions[i];
    if (dimIndex < 0 || dimIndex >= resultRank)
      return emitOptionalError(location,
                               "broadcast_dimensions contains invalid value ",
                               dimIndex, " for result with rank ", resultRank);
    auto dimSize = operandType.getDimSize(i);
    auto resultDimSize = resultType.getDimSize(dimIndex);
    // Note: verifyCompatibleShapes doesn't consider size-1 broadcasting, so
    // we add a manual check for this.
    if (dimSize != 1 && !verifyCompatibleDims(dimSize, resultDimSize))
      return emitOptionalError(location, "size of operand dimension ", i, " (",
                               dimSize,
                               ") is not compatible "
                               "with size of result dimension ",
                               dimIndex, " (", resultDimSize, ")");
  }

  // dynamic_broadcast_in_dim_c7
  if (failed(verifyShapeOperandIsCompatibleWithResultType(
          location, outputDimensions, resultType)))
    return failure();

  int64_t numKnownExpansionBehavior = 0;
  DenseSet<int64_t> knownExpansionBehavior;
  auto collectExpansionBehaviorDims =
      [&](const std::optional<ArrayRef<int64_t>> &attr) {
        if (!attr)
          return;
        for (const auto &i : attr.value()) {
          numKnownExpansionBehavior++;
          knownExpansionBehavior.insert(i);
        }
      };
  collectExpansionBehaviorDims(knownExpandingDimensions);
  collectExpansionBehaviorDims(knownNonexpandingDimensions);

  // dynamic_broadcast_in_dim_c8
  if (knownExpansionBehavior.size() != numKnownExpansionBehavior)
    return emitOptionalError(
        location,
        "duplicate expansion hint for at least one operand dimension");

  // dynamic_broadcast_in_dim_c9, dynamic_broadcast_in_dim_c10
  for (int64_t i : knownExpansionBehavior)
    if (i < 0 || i >= operandType.getRank())
      return emitOptionalError(location, "hint for expanding dimension ", i,
                               " does not refer to a "
                               "valid operand dimension");
  if (SmallVector<int64_t> shape;
      operandType.hasStaticShape() &&
      matchInts(outputDimensions, shape).succeeded()) {
    for (auto [i, dimIndex] : llvm::enumerate(broadcastDimensions)) {
      if (!operandType.isDynamicDim(i)) {
        auto dimSize = operandType.getDimSize(i);
        auto shapeDimSize = shape[dimIndex];
        if (dimSize != 1 && dimSize != shapeDimSize)
          return emitOptionalError(
              location, "size of operand dimension ", i, " (", dimSize,
              ") is not equal to 1 or value of shape at index ", dimIndex, " (",
              shapeDimSize, ")");
      }
    }
  }

  return success();
}

LogicalResult verifyDynamicIotaOp(std::optional<Location> location,
                                  Value outputShape, int64_t iotaDimension,
                                  Value result) {
  auto resultType = cast<ShapedType>(result.getType());

  // dynamic_iota_c1
  if (iotaDimension >= resultType.getRank())
    return emitOptionalError(
        location, "iota dimension cannot go beyond the output rank.");
  // dynamic_iota_c2
  if (failed(verifyShapeOperandIsCompatibleWithResultType(location, outputShape,
                                                          resultType)))
    return failure();

  return success();
}

LogicalResult verifyDynamicPadOp(std::optional<Location> location,
                                 Value operand, Value paddingValue,
                                 Value edgePaddingLow, Value edgePaddingHigh,
                                 Value result) {
  auto inputType = cast<RankedTensorType>(operand.getType());
  int inputRank = inputType.getRank();

  // dynamic_pad_c2
  auto paddingLowType = cast<RankedTensorType>(edgePaddingLow.getType());
  auto paddingSize = paddingLowType.getDimSize(0);
  if (paddingSize != inputRank)
    return emitOptionalError(location, "padding operands size (", paddingSize,
                             ") must match operand rank (", inputRank, ")");

  auto outputType = cast<RankedTensorType>(result.getType());
  if (!inputType.hasStaticShape() || !outputType.hasStaticShape())
    return success();

  SmallVector<int64_t> edgePaddingLowValues;
  if (failed(matchInts(edgePaddingLow, edgePaddingLowValues)))
    return success();

  SmallVector<int64_t> edgePaddingHighValues;
  if (failed(matchInts(edgePaddingHigh, edgePaddingHighValues)))
    return success();

  // dynamic_pad_c4
  for (auto [i, in, out, low, high] :
       llvm::enumerate(inputType.getShape(), outputType.getShape(),
                       edgePaddingLowValues, edgePaddingHighValues)) {
    auto want = in + low + high;
    if (out != want)
      return emitOptionalError(location, "expected output dimension at index ",
                               i, " to equal ", want, ", but got ", out);
  }

  return success();
}

LogicalResult verifyDynamicReshapeOp(std::optional<Location> location,
                                     Value operand, Value outputShape,
                                     Value result) {
  // dynamic_reshape_c1
  if (!isCompatibleElementTypeForHloTypeInference(operand.getType(),
                                                  result.getType()))
    return emitOptionalError(
        location,
        "expects operand and result to have compatible element type. Got: ",
        operand.getType(), " and ", result.getType());

  // dynamic_reshape_c2
  auto resultType = cast<ShapedType>(result.getType());
  auto operandType = cast<ShapedType>(operand.getType());
  if (resultType.hasStaticShape() && operandType.hasStaticShape()) {
    int64_t numResultElements = resultType.getNumElements();
    int64_t numOperandElements = operandType.getNumElements();
    if (numResultElements != numOperandElements)
      return emitOptionalError(location, "number of output elements (",
                               numResultElements,
                               ") doesn't match expected number of elements (",
                               numOperandElements, ")");
  }

  // dynamic_reshape_c4
  if (failed(verifyShapeOperandIsCompatibleWithResultType(location, outputShape,
                                                          resultType)))
    return failure();

  auto outputShapeType = cast<ShapedType>(outputShape.getType());
  if (outputShapeType.getDimSize(0) != resultType.getRank())
    return emitOptionalError(location,
                             "result should have a rank equal to the number of "
                             "elements in output_shape");

  if (SmallVector<int64_t> shape; operandType.hasStaticShape() &&
                                  matchInts(outputShape, shape).succeeded()) {
    int64_t operandCount = operandType.getNumElements();
    int64_t shapeCount = std::accumulate(shape.begin(), shape.end(), int64_t{1},
                                         std::multiplies<int64_t>());
    if (operandCount != shapeCount) {
      return emitOptionalError(location,
                               "output_shape is incompatible with input type "
                               "of operation: input has ",
                               operandCount, " elements, but output_shape has ",
                               shapeCount);
    }
  }

  return success();
}

LogicalResult verifyIotaOp(std::optional<Location> location,
                           int64_t iotaDimension, Value result) {
  auto shape = cast<ShapedType>(result.getType());
  if (shape.getRank() == 0)
    return emitOptionalError(location, "does not support scalars.");

  if (iotaDimension >= shape.getRank())
    return emitOptionalError(
        location, "iota dimension cannot go beyond the output rank.");
  return success();
}

// Verifies that the operand rank matches the
// start_indices/limit_indices/strides size
LogicalResult verifyRealDynamicSliceOp(std::optional<Location> location,
                                       Value operand, Value startIndices,
                                       Value limitIndices, Value strides) {
  auto inputType = cast<RankedTensorType>(operand.getType());
  int inputRank = inputType.getRank();

  auto startType = cast<RankedTensorType>(startIndices.getType());
  auto limitType = cast<RankedTensorType>(limitIndices.getType());
  auto stridesType = cast<RankedTensorType>(strides.getType());

  if (inputRank != startType.getNumElements())
    return emitOptionalError(
        location, "has mismatched number of operand rank (", inputRank,
        ") and start_indices size (", startType.getNumElements(), ")");

  if (inputRank != limitType.getNumElements())
    return emitOptionalError(
        location, "has mismatched number of operand rank (", inputRank,
        ") and limit_indices size (", limitType.getNumElements(), ")");

  if (inputRank != stridesType.getNumElements())
    return emitOptionalError(
        location, "has mismatched number of operand rank (", inputRank,
        ") and strides size (", stridesType.getNumElements(), ")");
  return success();
}

LogicalResult verifyReduceOp(std::optional<Location> location,
                             ValueRange inputs, ValueRange initValues,
                             ArrayRef<int64_t> dimensions, Region &body) {
  auto inputTypes = llvm::map_to_vector(
      inputs.getTypes(), [](Type t) { return cast<ShapedType>(t); });
  auto initValueTypes = llvm::map_to_vector(
      initValues.getTypes(), [](Type t) { return cast<ShapedType>(t); });

  SmallVector<int64_t> newDimensions;
  Attribute encoding;
  // reduce_c1, reduce_c4, reduce_c5, reduce_i3
  if (failed(verifyReduceOpInputsAndInferShape(location, inputTypes, dimensions,
                                               newDimensions, encoding)))
    return failure();

  // reduce_c2, reduce_c6
  if (failed(verifyReducerShape(location, body.front(), inputTypes,
                                initValueTypes, newDimensions)))
    return failure();
  return success();
}

LogicalResult verifyReduceOpInputsAndInferShape(
    std::optional<Location> location, SmallVector<ShapedType> inputTypes,
    ArrayRef<int64_t> dimensions, SmallVector<int64_t> &newDimensions,
    Attribute &encoding) {
  // reduce_c1
  auto witnessType = cast<RankedTensorType>(inputTypes[0]);
  for (size_t i = 1; i < inputTypes.size(); i++)
    if (failed(mlir::verifyCompatibleShape(witnessType, inputTypes[i])))
      return emitOptionalError(
          location,
          "expects all inputs to have compatible shapes. Shape at input-index ",
          i, " is not compatible with shape at input-index 0");

  DenseSet<int64_t> dimensionsToReduceSet;
  for (int64_t dimension : dimensions) {
    // reduce_c4
    if (dimension < 0 || dimension >= witnessType.getRank())
      return emitOptionalError(location, "Out-of-bounds dimension ", dimension,
                               ", expected to be in range [0, ",
                               witnessType.getRank(), ')');

    // reduce_c5
    if (!dimensionsToReduceSet.insert(dimension).second)
      return emitOptionalError(location,
                               "Duplicate reduction dimension: ", dimension);
  }

  ArrayRef<int64_t> inputBounds = encodingToBounds(witnessType.getEncoding());
  SmallVector<int64_t> newBounds;
  for (int inputIdx = 0; inputIdx < witnessType.getRank(); ++inputIdx) {
    if (!dimensionsToReduceSet.count(inputIdx)) {
      newDimensions.push_back(witnessType.getDimSize(inputIdx));
      if (!inputBounds.empty())
        newBounds.push_back(inputBounds[inputIdx]);
    }
  }

  // Set encoding based on the bounds only if the bounds is not empty.
  encoding = nullptr;
  if (!newBounds.empty())
    encoding = boundsToEncoding(witnessType.getEncoding(), newBounds);
  return success();
}

LogicalResult verifyReduceWindowOpInputsAndInferWindow(
    std::optional<Location> location, SmallVector<ShapedType> inputTypes,
    SmallVector<ShapedType> initValueTypes, ArrayRef<int64_t> windowDimensions,
    std::optional<ArrayRef<int64_t>> windowStrides,
    std::optional<ArrayRef<int64_t>> baseDilations,
    std::optional<ArrayRef<int64_t>> windowDilations,
    std::optional<DenseIntElementsAttr> padding,
    SmallVector<int64_t> &windowDims,
    SmallVector<WindowDimension> &inferredWindow) {
  // reduce_window_c1
  if (inputTypes.empty())
    return emitOptionalError(location, "requires at least 1 input value");

  auto witnessType = cast<RankedTensorType>(inputTypes[0]);
  // reduce_window_c2
  for (size_t i = 1; i < inputTypes.size(); i++)
    if (failed(mlir::verifyCompatibleShape(witnessType, inputTypes[i])))
      return emitOptionalError(
          location,
          "expects all inputs to have compatible shapes. Shape at input-index ",
          i, " is not compatible with shape at input-index 0");

  // reduce_window_c12, reduce_window_i7
  auto paddingOrErr = convertPaddingAttribute(padding, location);
  if (failed(paddingOrErr))
    return failure();

  // reduce_window_c4
  for (const auto inputType : inputTypes) {
    if (inputType.getRank() != static_cast<int64_t>(windowDimensions.size()))
      return emitOptionalError(
          location, "expects window-dimensions size == input rank, but got ",
          "window-dimensions size: ", windowDimensions.size(),
          " and input: ", inputType, " with rank = ", inputType.getRank(), ".");
  }

  // reduce_window_c5...reduce_window_c12
  auto windowOrErr = verifyWindowAttributesAndInferWindowDimensions(
      windowDimensions, windowStrides.value_or(SmallVector<int64_t, 0>{}),
      *paddingOrErr,
      /*lhsDilation=*/baseDilations.value_or(SmallVector<int64_t, 0>{}),
      /*rhsDilation=*/windowDilations.value_or(SmallVector<int64_t, 0>{}),
      /*windowReversal=*/{}, location);
  if (failed(windowOrErr))
    return failure();

  windowDims.append(windowDimensions.begin(), windowDimensions.end());
  inferredWindow.append(*windowOrErr);
  return success();
}

LogicalResult
verifyReduceWindowOp(std::optional<Location> location, ValueRange inputs,
                     ValueRange initValues, ArrayRef<int64_t> windowDimensions,
                     std::optional<ArrayRef<int64_t>> windowStrides,
                     std::optional<ArrayRef<int64_t>> baseDilations,
                     std::optional<ArrayRef<int64_t>> windowDilations,
                     std::optional<DenseIntElementsAttr> padding,
                     Region &body) {
  auto inputTypes = llvm::map_to_vector(
      inputs.getTypes(), [](Type t) { return cast<ShapedType>(t); });
  auto initValueTypes = llvm::map_to_vector(
      initValues.getTypes(), [](Type t) { return cast<ShapedType>(t); });

  SmallVector<int64_t> windowDims;
  SmallVector<WindowDimension> inferredWindow;
  // reduce_window_c1, reduce_window_c2, reduce_window_c4...reduce_window_c12,
  // reduce_window_i4...reduce_window_i7
  if (failed(verifyReduceWindowOpInputsAndInferWindow(
          location, inputTypes, initValueTypes, windowDimensions, windowStrides,
          baseDilations, windowDilations, padding, windowDims, inferredWindow)))
    return failure();

  // reduce_window_c3, reduce_window_c13, reduce_window_i2
  if (failed(verifyReducerShape(location, body.front(), inputTypes,
                                initValueTypes, windowDims)))
    return failure();

  return success();
}

LogicalResult verifyReshapeOp(std::optional<Location> location, Value operand,
                              Value result) {
  // If the operand type is dynamically shaped there is nothing to verify.
  auto operandTy = cast<RankedTensorType>(operand.getType());
  auto resultTy = cast<RankedTensorType>(result.getType());
  if (!operandTy.hasStaticShape() || !resultTy.hasStaticShape())
    return success();

  // If the operand type is statically shaped (not required) the number of
  // elements must match that of the result type.
  int64_t numResultElements = resultTy.getNumElements();
  int64_t numOperandElements = operandTy.getNumElements();
  if (numResultElements != numOperandElements)
    return emitOptionalError(location, "number of output elements (",
                             numResultElements,
                             ") doesn't match expected number of elements (",
                             numOperandElements, ")");

  return success();
}

LogicalResult verifyBitReverseOp(std::optional<Location> location,
                                 Value operand, ArrayRef<int64_t> dimensions) {
  llvm::SmallDenseSet<int64_t> uniqueDims(dimensions.begin(), dimensions.end());
  if (uniqueDims.size() != dimensions.size())
    return emitOptionalError(location,
                             "dimensions should be unique. Got: ", dimensions);
  auto operandTy = cast<RankedTensorType>(operand.getType());
  for (int64_t dim : dimensions) {
    if (dim < 0)
      return emitOptionalError(
          location,
          "all dimensions should be non-negative. Got dimension: ", dim, ".");
    if (dim >= operandTy.getRank())
      return emitOptionalError(
          location, "all dimensions should be between [0, ",
          operandTy.getRank(), "). Got dimension: ", dim, ".");
    // Each dimension size must be a power of 2.
    int64_t dimSize = operandTy.getDimSize(dim);
    if (dimSize != ShapedType::kDynamic && (dimSize & (dimSize - 1)) != 0)
      return emitOptionalError(location,
                               "dimension size must be a power of 2, got ",
                               dimSize, " for dimension ", dim, ".");
  }
  return success();
}

LogicalResult verifyReverseOp(std::optional<Location> location, Value operand,
                              ArrayRef<int64_t> dimensions) {
  llvm::SmallDenseSet<int64_t> uniqueDims(dimensions.begin(), dimensions.end());
  // reverse_c2
  if (uniqueDims.size() != dimensions.size())
    return emitOptionalError(location,
                             "dimensions should be unique. Got: ", dimensions);
  auto operandTy = cast<RankedTensorType>(operand.getType());
  for (int64_t dim : dimensions) {
    // reverse_c3
    if (dim < 0)
      return emitOptionalError(
          location,
          "all dimensions should be non-negative. Got dimension: ", dim, ".");
    if (dim >= operandTy.getRank())
      return emitOptionalError(
          location, "all dimensions should be between [0, ",
          operandTy.getRank(), "). Got dimension: ", dim, ".");
  }
  return success();
}

LogicalResult verifyScatterOp(
    std::optional<Location> location, ValueRange inputs, Value scatterIndices,
    ValueRange updates, ArrayRef<int64_t> updateWindowDims,
    ArrayRef<int64_t> insertedWindowDims, ArrayRef<int64_t> inputBatchingDims,
    ArrayRef<int64_t> scatterIndicesBatchingDims,
    ArrayRef<int64_t> scatterDimsToOperandDims, int64_t indexVectorDim,
    Region &updateComputation) {
  // Get the first operand and update, since variadic Scatter is not yet
  // implemented
  auto numOperands = inputs.size();
  auto scatterIndicesType = cast<ShapedType>(scatterIndices.getType());

  auto operandTypes = llvm::map_to_vector(
      inputs.getTypes(), [](Type type) { return cast<ShapedType>(type); });
  auto updatesTypes = llvm::map_to_vector(
      updates.getTypes(), [](Type type) { return cast<ShapedType>(type); });

  // scatter_c1
  for (auto operandType : operandTypes)
    if (failed(verifyCompatibleShape(operandTypes[0].getShape(),
                                     operandType.getShape())))
      return emitOptionalError(location,
                               "Not all inputs have compatible shapes.");

  // scatter_c3
  for (auto updateType : updatesTypes)
    if (failed(verifyCompatibleShape(updatesTypes[0].getShape(),
                                     updateType.getShape())))
      return emitOptionalError(location,
                               "Not all updates have compatible shapes.");

  // scatter_c22
  if (failed(checkDimInBounds(location, indexVectorDim,
                              scatterIndicesType.getRank(), "index_vector_dim",
                              "rank-of('scatter_indices')",
                              /*upperBoundInclusive=*/true)))
    return failure();

  SmallVector<ShapedType> inputTypes, initValueTypes;
  for (int64_t i = 0; i < static_cast<int64_t>(numOperands); i++) {
    inputTypes.push_back(operandTypes[i]);
    initValueTypes.push_back(
        RankedTensorType::get({}, updatesTypes[i].getElementType()));
  }
  // scatter_c6, scatter_c23
  if (failed(verifyReducerShape(location, updateComputation.front(), inputTypes,
                                initValueTypes,
                                /*allowedDimensions=*/{})))
    return failure();

  // rank-of('updates[i]') == size-of('update_window_dims') +
  // rank-of('scatter_indices') - 1, where 'scatter_indices' is expanded by a
  // trailing 1 dimension if 'index_vector_dim' == rank-of('scatter_indices')
  // for all values of `i`.
  SmallVector<int64_t> expandedScatterIndicesShape =
      llvm::to_vector(scatterIndicesType.getShape());
  if (static_cast<int64_t>(expandedScatterIndicesShape.size()) ==
      indexVectorDim)
    expandedScatterIndicesShape.push_back(1);

  // scatter_c4
  for (int64_t i = 0; i < static_cast<int64_t>(numOperands); i++) {
    int64_t expectedUpdatesRank =
        expandedScatterIndicesShape.size() - 1 + updateWindowDims.size();
    if (updatesTypes[i].getRank() != expectedUpdatesRank)
      return emitOptionalError(
          location, "expects updates tensor must be of rank ",
          expectedUpdatesRank,
          " ( == rank-of('scatter_indices') - 1 + "
          "size-of('update_window_dims'), where 'scatter_indices' is "
          "expanded by a trailing 1 dimension if 'index_vector_dim' == "
          "rank-of('scatter_indices')), but got ",
          updatesTypes[i].getRank(), ".");
  }

  // scatter_c2, scatter_c7...scatter_c21
  for (int64_t i = 0; i < static_cast<int64_t>(numOperands); i++) {
    if (failed(validateScatterDimensionNumbers(
            operandTypes[i], expandedScatterIndicesShape, updatesTypes[i],
            updateWindowDims, insertedWindowDims, inputBatchingDims,
            scatterIndicesBatchingDims, scatterDimsToOperandDims,
            indexVectorDim, location)))
      return failure();
  }

  for (int64_t i = 0; i < static_cast<int64_t>(numOperands); i++) {
    auto updatesShape = updatesTypes[i].getShape();
    auto operandShape = operandTypes[i].getShape();

    int64_t insertedDimsSeen = 0;
    int64_t batchingDimsSeen = 0;
    SmallVector<int64_t> maxUpdateSliceSizes;
    const auto dimensionsSize = operandTypes[i].getRank();
    maxUpdateSliceSizes.reserve(dimensionsSize);
    for (int dim = 0; dim < dimensionsSize; ++dim) {
      if (insertedDimsSeen < static_cast<int64_t>(insertedWindowDims.size()) &&
          insertedWindowDims[insertedDimsSeen] == dim)
        ++insertedDimsSeen;
      else if (batchingDimsSeen <
                   static_cast<int64_t>(inputBatchingDims.size()) &&
               inputBatchingDims[batchingDimsSeen] == dim)
        ++batchingDimsSeen;
      else
        maxUpdateSliceSizes.push_back(operandShape[dim]);
    }

    for (int64_t i = 0; i < static_cast<int64_t>(updateWindowDims.size());
         ++i) {
      auto updateWindowDim = updateWindowDims[i];

      if (isDynamicDimSize(updatesShape[updateWindowDim]) ||
          isDynamicDimSize(maxUpdateSliceSizes[i]))
        continue;

      // scatter_c4
      if (updatesShape[updateWindowDim] > maxUpdateSliceSizes[i]) {
        return emitOptionalError(
            location,
            "expects bounds of the window dimensions of updates to not "
            "exceed the bounds of the corresponding dimensions of operand. "
            "For dimension ",
            updateWindowDim, ", updates bound is ",
            updatesShape[updateWindowDim], ", operand bound is ",
            maxUpdateSliceSizes[i], ".");
      }
    }

    int64_t scatterDimsSeen = 0;
    for (int64_t i = 0; i < static_cast<int64_t>(updatesShape.size()); ++i) {
      bool isUpdateWindowDim = std::binary_search(updateWindowDims.begin(),
                                                  updateWindowDims.end(), i);

      if (isUpdateWindowDim)
        continue;
      if (scatterDimsSeen == indexVectorDim)
        ++scatterDimsSeen;

      // scatter_c4
      if (!verifyCompatibleDims(updatesShape[i],
                                expandedScatterIndicesShape[scatterDimsSeen]))
        return emitOptionalError(
            location,
            "expects bounds of the scatter dimensions of updates to be "
            "same as the bounds of the corresponding dimensions of scatter "
            "indices. For scatter dimension ",
            i, ", updates bound is ", updatesShape[i],
            " , scatter_indices bound is ",
            expandedScatterIndicesShape[scatterDimsSeen], ".");

      ++scatterDimsSeen;
    }
  }

  return success();
}

LogicalResult verifySortOp(std::optional<Location> location, ValueRange inputs,
                           int64_t dimension, Region &comparator) {
  auto operandTypes = inputs.getTypes();
  if (!operandTypes.empty()) {
    auto operandShapedType = cast<ShapedType>(operandTypes.front());
    int64_t cmpDim = dimension;
    int64_t rank = operandShapedType.getRank();
    // sort_c4
    if (cmpDim < -rank || cmpDim >= rank)
      return emitOptionalError(location,
                               "dimension attribute value must be in range [-",
                               rank, ", ", rank, "), but found ", cmpDim);
    // ODS SameOperandsAndResultShape asserts inputs have same shape
  }

  Block &block = comparator.front();
  // sort_c5
  size_t numOperands = operandTypes.size();
  if (block.getNumArguments() != 2 * numOperands)
    return emitOptionalError(location, "comparator block should have ",
                             2 * numOperands, " arguments");
  // sort_c5
  for (const auto &indexedOperandType : llvm::enumerate(operandTypes)) {
    int index = indexedOperandType.index();
    Type elementType =
        cast<ShapedType>(indexedOperandType.value()).getElementType();
    Type shapedType = RankedTensorType::get({}, elementType);
    for (int i : {2 * index, 2 * index + 1}) {
      Type argType = block.getArgument(i).getType();
      if (argType != shapedType)
        return emitOptionalError(location, "comparator block argument #", i,
                                 " should be of type ", shapedType, " but got ",
                                 argType);
    }
  }

  // sort_c5
  auto comparatorResult = block.getTerminator()->getOperands();
  if (comparatorResult.size() != 1)
    return emitOptionalError(location,
                             "comparator must return single output but got ",
                             comparatorResult.size());
  // sort_c5
  auto comparatorResultType = cast<ShapedType>(comparatorResult[0].getType());
  if (comparatorResultType.getRank() != 0 ||
      !comparatorResultType.getElementType().isInteger(1))
    return emitOptionalError(location,
                             "comparator must return tensor<i1> but got ",
                             comparatorResult[0].getType());
  return success();
}

LogicalResult verifyWhileOp(std::optional<Location> location,
                            ValueRange operand, Region &cond, Region &body) {
  auto operandTypes = operand.getTypes();
  auto condArgsTypes = cond.front().getArgumentTypes();
  auto bodyArgsTypes = body.front().getArgumentTypes();
  // while_c1
  if (!isCompatibleForHloTypeInference(operandTypes, condArgsTypes))
    return emitOptionalError(location,
                             "expect operands to be compatible with condition "
                             "block arguments but got ",
                             operandTypes, " vs ", condArgsTypes);
  // while_c2
  if (!isCompatibleForHloTypeInference(operandTypes, bodyArgsTypes))
    return emitOptionalError(
        location,
        "expect operands to be compatible with body block arguments but got ",
        operandTypes, " vs ", bodyArgsTypes);
  // while_c2
  auto bodyReturnTypes = body.front().getTerminator()->getOperandTypes();
  if (!isCompatibleForHloTypeInference(operandTypes, bodyReturnTypes))
    return emitOptionalError(location,
                             "expect operands to be compatible with body block "
                             "return types but got ",
                             operandTypes, " vs ", bodyReturnTypes);
  // while_c1
  auto condReturnTypes = cond.front().back().getOperandTypes();
  if (condReturnTypes.size() != 1)
    return emitOptionalError(
        location, "expect condition body returns a single value but got ",
        condReturnTypes.size());
  // while_c1
  auto operandType = cast<ShapedType>(condReturnTypes[0]);
  if (operandType.getRank() != 0 || !operandType.getElementType().isInteger(1))
    return emitOptionalError(
        location,
        "expect condition block return a zero-ranked tensor of i1 but got ",
        condReturnTypes[0]);

  return success();
}

// ZK: verifyPrecisionConfig check (dot_general_c11) omitted - precision_config
// not ported
LogicalResult
checkDotGeneralConstraints(std::optional<Location> location, Type lhsType,
                           Type rhsType,
                           ArrayRef<int64_t> lhsBatchingDimensions,
                           ArrayRef<int64_t> rhsBatchingDimensions,
                           ArrayRef<int64_t> lhsContractingDimensions,
                           ArrayRef<int64_t> rhsContractingDimensions) {
  // dot_general_c1
  if (lhsBatchingDimensions.size() != rhsBatchingDimensions.size())
    return emitOptionalError(location, "lhs and rhs should have the same "
                                       "number of batching dimensions");
  // dot_general_c2
  if (lhsContractingDimensions.size() != rhsContractingDimensions.size())
    return emitOptionalError(location, "lhs and rhs should have the same "
                                       "number of contracting dimensions");
  // dot_general_c3
  if (failed(checkDimsDistinct(
          location, lhsBatchingDimensions, lhsContractingDimensions,
          "lhs_batching_dimensions", "lhs_contracting_dimensions")))
    return failure();
  // dot_general_c4
  if (failed(checkDimsDistinct(
          location, rhsBatchingDimensions, rhsContractingDimensions,
          "rhs_batching_dimensions", "rhs_contracting_dimensions")))
    return failure();

  auto checkDimsInRange = [&](int64_t rank, ArrayRef<int64_t> dims,
                              llvm::StringRef dimName) -> LogicalResult {
    auto inRange = [&](int64_t i) -> bool { return 0 <= i && i < rank; };
    const auto *dimsNotInRange =
        std::find_if_not(dims.begin(), dims.end(), inRange);
    if (dimsNotInRange != dims.end())
      return emitOptionalError(location, dimName, " value: ", *dimsNotInRange,
                               " is out of range: ", "[0, ", rank, ")");
    return success();
  };

  auto lhsRankedType = cast<RankedTensorType>(lhsType);
  // dot_general_c5, dot_general_c6
  if (failed(checkDimsInRange(lhsRankedType.getRank(), lhsBatchingDimensions,
                              "lhs_batching_dimensions")) ||
      failed(checkDimsInRange(lhsRankedType.getRank(), lhsContractingDimensions,
                              "lhs_contracting_dimensions")))
    return failure();

  auto rhsRankedType = cast<RankedTensorType>(rhsType);
  // dot_general_c7, dot_general_c8
  if (failed(checkDimsInRange(rhsRankedType.getRank(), rhsBatchingDimensions,
                              "rhs_batching_dimensions")) ||
      failed(checkDimsInRange(rhsRankedType.getRank(), rhsContractingDimensions,
                              "rhs_contracting_dimensions")))
    return failure();

  auto lhsShape = lhsRankedType.getShape();
  auto rhsShape = rhsRankedType.getShape();

  // dot_general_c9
  for (auto [lhs, rhs] :
       llvm::zip(lhsBatchingDimensions, rhsBatchingDimensions)) {
    if (!verifyCompatibleDims(lhsShape[lhs], rhsShape[rhs]))
      return emitOptionalError(
          location, "batching dimension sizes must match for lhs/rhs");
  }
  // dot_general_c10
  for (auto [lhs, rhs] :
       llvm::zip(lhsContractingDimensions, rhsContractingDimensions)) {
    if (!verifyCompatibleDims(lhsShape[lhs], rhsShape[rhs]))
      return emitOptionalError(
          location, "contracting dimension sizes must match for lhs/rhs");
  }
  return success();
}

// ZK: Element type inference and quantization constraints (dot_general_c14~c20)
// omitted - quantization not ported
LogicalResult
inferDotGeneralOp(std::optional<Location> location, Type lhsType, Type rhsType,
                  ArrayRef<int64_t> lhsBatchingDimensions,
                  ArrayRef<int64_t> rhsBatchingDimensions,
                  ArrayRef<int64_t> lhsContractingDimensions,
                  ArrayRef<int64_t> rhsContractingDimensions,
                  SmallVectorImpl<ShapedTypeComponents> &inferredReturnShapes) {
  if (failed(checkDotGeneralConstraints(
          location, lhsType, rhsType, lhsBatchingDimensions,
          rhsBatchingDimensions, lhsContractingDimensions,
          rhsContractingDimensions)))
    return failure();

  SmallVector<int64_t> dimensions;
  auto lhsRankedType = cast<RankedTensorType>(lhsType);
  auto rhsRankedType = cast<RankedTensorType>(rhsType);
  auto lhsShape = lhsRankedType.getShape();
  auto rhsShape = rhsRankedType.getShape();

  for (const int64_t lhsBatchingDim : lhsBatchingDimensions)
    dimensions.push_back(lhsShape[lhsBatchingDim]);
  for (int64_t i = 0; i < lhsRankedType.getRank(); i++)
    if (!llvm::is_contained(lhsBatchingDimensions, i) &&
        !llvm::is_contained(lhsContractingDimensions, i))
      dimensions.push_back(lhsShape[i]);
  for (int64_t i = 0; i < rhsRankedType.getRank(); i++)
    if (!llvm::is_contained(rhsBatchingDimensions, i) &&
        !llvm::is_contained(rhsContractingDimensions, i))
      dimensions.push_back(rhsShape[i]);

  // dot_general_c12
  inferredReturnShapes.emplace_back(dimensions);
  return success();
}

// ZK: precision_config/algorithm validation (dot_general_c21) and quantization
// constraints omitted - not ported
LogicalResult verifyDotGeneralOp(std::optional<Location> location, Value lhs,
                                 Value rhs,
                                 ArrayRef<int64_t> lhsBatchingDimensions,
                                 ArrayRef<int64_t> rhsBatchingDimensions,
                                 ArrayRef<int64_t> lhsContractingDimensions,
                                 ArrayRef<int64_t> rhsContractingDimensions,
                                 Value result) {
  SmallVector<ShapedTypeComponents> inferredReturnShapes;
  if (failed(inferDotGeneralOp(location, lhs.getType(), rhs.getType(),
                               lhsBatchingDimensions, rhsBatchingDimensions,
                               lhsContractingDimensions,
                               rhsContractingDimensions, inferredReturnShapes)))
    return failure();

  auto inferredShape = inferredReturnShapes[0];
  auto resultType = cast<ShapedType>(result.getType());
  if (failed(verifyCompatibleShape(inferredShape.getDims(),
                                   resultType.getShape())))
    return emitOptionalError(
        location, "inferred shape '[",
        llvm::make_range(inferredShape.getDims().begin(),
                         inferredShape.getDims().end()),
        "]' is incompatible with return type of operation ", resultType);

  return success();
}

} // namespace mlir::hlo
